<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/database/requests.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/database/requests.py" />
              <option name="originalContent" value="import os&#10;from datetime import datetime&#10;from sqlalchemy import select&#10;from app.database.models import async_session, PendingPost, ScheduledPost, LastMessage, PostIsPinned, BroadcastPost, BroadcastConfig&#10;&#10;&#10;async def get_pin_info(post_id: int):&#10;    async with async_session() as session:&#10;        existing = await session.scalar(select(PostIsPinned).where(PostIsPinned.post_id == post_id))&#10;        return existing.pinned if existing else False&#10;&#10;&#10;async def set_pin_info(post_id: int, pinned: bool):&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            existing = await session.scalar(select(PostIsPinned).where(PostIsPinned.post_id == post_id).with_for_update())&#10;            if existing:&#10;                existing.pinned = pinned&#10;                session.add(existing)&#10;            else:&#10;                session.add(PostIsPinned(post_id=post_id, pinned=pinned))&#10;        await session.commit()&#10;&#10;&#10;async def get_last_message_time():&#10;    async with async_session() as session:&#10;        messages = await session.scalars(select(LastMessage))&#10;        res = [[msg.id, msg.time] for msg in messages]&#10;        await session.commit()&#10;        return None if not res else max(res)[1]&#10;&#10;&#10;async def add_last_message_time(time):&#10;    async with async_session() as session:&#10;        session.add(LastMessage(time=time))&#10;        await session.commit()&#10;&#10;&#10;async def delete_last_messages():&#10;    async with async_session() as session:&#10;        await session.delete(LastMessage)&#10;        await session.commit()&#10;&#10;&#10;async def add_or_update_pending_post(content_type: str, text: str, photo_file_ids: list[str], media_group_id: int = 0, chat_id: int | None = None):&#10;    post = PendingPost(&#10;        content_type=content_type,&#10;        text=text,&#10;        photo_file_ids=photo_file_ids,&#10;        media_group_id=media_group_id if media_group_id else 0,&#10;        chat_id=chat_id or int(os.getenv('MAIN_CHAT_ID', 0))&#10;    )&#10;&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            # Проверяем существование с lock (with_for_update)&#10;            existing = await session.scalar(&#10;                select(PendingPost)&#10;                .where(PendingPost.media_group_id == post.media_group_id,&#10;                       PendingPost.media_group_id != 0)&#10;                .with_for_update()&#10;            )&#10;            if existing:&#10;                # Обновляем существующий: добавляем новые file_ids&#10;                existing.photo_file_ids.extend(photo_file_ids)&#10;                existing.text = text or existing.text  # Сохраняем caption, если новый&#10;                if chat_id:&#10;                    existing.chat_id = chat_id&#10;                session.add(existing)&#10;            else:&#10;                session.add(post)&#10;        await session.commit()&#10;&#10;&#10;async def get_pending_posts():&#10;    async with async_session() as session:&#10;        posts = await session.scalars(select(PendingPost))&#10;        return posts.all()&#10;&#10;&#10;async def delete_pending_post(post_id: int):&#10;    async with async_session() as session:&#10;        post = await session.get(PendingPost, post_id)&#10;        if post:&#10;            await session.delete(post)&#10;            await session.commit()&#10;            return True&#10;        return False&#10;&#10;&#10;async def add_or_update_scheduled_post(&#10;    content_type: str,&#10;    text: str | None = None,&#10;    photo_file_ids: list[str] | None = None,&#10;    scheduled_time: datetime | None = None,&#10;    media_group_id: int = 0,&#10;    is_published: bool = False,&#10;    message_ids: list | None = None,&#10;    unpin_time: datetime | None = None,&#10;    delete_time: datetime | None = None,&#10;    post_id: int = 0,&#10;    chat_id: int | None = None&#10;):&#10;    if message_ids is None:&#10;        message_ids = []&#10;    if not photo_file_ids:&#10;        photo_file_ids = []&#10;    post = ScheduledPost(&#10;        content_type=content_type,&#10;        text=text,&#10;        photo_file_ids=photo_file_ids.copy(),  # копируем список во избежание мутации аргумента&#10;        scheduled_time=scheduled_time,&#10;        media_group_id=media_group_id or 0,&#10;        is_published=is_published,&#10;        message_ids=message_ids.copy(),&#10;        unpin_time=unpin_time,&#10;        delete_time=delete_time,&#10;        chat_id=chat_id or int(os.getenv('MAIN_CHAT_ID', 0))&#10;    )&#10;&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            existing = await session.scalar(&#10;                select(ScheduledPost)&#10;                .where(&#10;                    ScheduledPost.id == post_id&#10;                )&#10;                .with_for_update()&#10;            )&#10;            if existing:&#10;                # Обновляем список photo_file_ids, добавляя новые уникальные элементы&#10;                updated_ids = existing.photo_file_ids or []&#10;                if photo_file_ids:&#10;                    for pid in photo_file_ids:&#10;                        if pid not in updated_ids:&#10;                            updated_ids.append(pid)&#10;                existing.photo_file_ids = updated_ids or existing.photo_file_ids&#10;&#10;                # Обновляем другие поля, если переданы значения&#10;&#10;                existing.text = text or existing.text&#10;                existing.scheduled_time = scheduled_time or existing.scheduled_time&#10;                existing.is_published = is_published&#10;                existing.message_ids = message_ids.copy() or existing.message_ids&#10;                existing.unpin_time = unpin_time or existing.unpin_time&#10;                existing.delete_time = delete_time or existing.delete_time&#10;                existing.chat_id = chat_id or existing.chat_id&#10;&#10;                session.add(existing)&#10;            else:&#10;                session.add(post)&#10;&#10;        await session.commit()&#10;&#10;&#10;async def get_scheduled_post(post_id: int):&#10;    async with async_session() as session:&#10;        post = await session.scalar(select(ScheduledPost).where(ScheduledPost.id == post_id))&#10;        return post&#10;&#10;&#10;async def get_scheduled_posts():&#10;    async with async_session() as session:&#10;        posts = await session.scalars(select(ScheduledPost))&#10;        return posts.all()&#10;&#10;&#10;async def delete_scheduled_post(post_id: int):&#10;    async with async_session() as session:&#10;        post = await session.get(ScheduledPost, post_id)&#10;        if post:&#10;            await session.delete(post)&#10;            await session.commit()&#10;            return True&#10;        return False&#10;&#10;&#10;async def add_broadcast_post(&#10;    content_type: str,&#10;    text: str | None,&#10;    photo_file_ids: list[str] | None,&#10;    media_group_id: int,&#10;    next_run_time: datetime,&#10;    end_time: datetime,&#10;    interval_minutes: int,&#10;    chat_id: int,&#10;    mode: str = 'full',&#10;    active_start_min: int | None = None,&#10;    active_end_min: int | None = None&#10;):&#10;    if not photo_file_ids:&#10;        photo_file_ids = []&#10;    if mode not in ('full', 'limited'):&#10;        mode = 'full'&#10;            else:&#10;                # если глобальная конфигурация выключена — fallback в full&#10;                mode = 'full'&#10;    post = BroadcastPost(&#10;        content_type=content_type,&#10;        text=text,&#10;        photo_file_ids=photo_file_ids.copy(),&#10;        media_group_id=media_group_id or 0,&#10;        next_run_time=next_run_time,&#10;        end_time=end_time,&#10;        chat_id=chat_id,&#10;        is_active=True,&#10;        mode=mode,&#10;        active_start_min=active_start_min if active_start_min is not None else 9*60,&#10;        active_end_min=active_end_min if active_end_min is not None else 23*60&#10;    )&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            session.add(post)&#10;        await session.commit()&#10;    return post&#10;&#10;&#10;async def get_active_broadcast_posts():&#10;    async with async_session() as session:&#10;        posts = await session.scalars(select(BroadcastPost).where(BroadcastPost.is_active == True))&#10;        return posts.all()&#10;&#10;&#10;async def update_broadcast_run(post_id: int, next_run_time: datetime | None, last_run_time: datetime, deactivate: bool = False):&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            bp = await session.get(BroadcastPost, post_id, with_for_update=True)&#10;            if not bp:&#10;                return False&#10;            bp.last_run_time = last_run_time&#10;            if deactivate:&#10;                bp.is_active = False&#10;            else:&#10;                bp.next_run_time = next_run_time&#10;            session.add(bp)&#10;        await session.commit()&#10;    return True&#10;&#10;&#10;async def stop_broadcast(post_id: int):&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            bp = await session.get(BroadcastPost, post_id, with_for_update=True)&#10;            if not bp:&#10;                return False&#10;            bp.is_active = False&#10;            session.add(bp)&#10;        await session.commit()&#10;    return True&#10;&#10;&#10;async def set_broadcast_mode(post_id: int, mode: str):&#10;    if mode not in ('full', 'limited'):&#10;        return False&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            bp = await session.get(BroadcastPost, post_id, with_for_update=True)&#10;            if not bp:&#10;                return False&#10;            bp.mode = mode&#10;            session.add(bp)&#10;        await session.commit()&#10;    return True&#10;&#10;&#10;async def update_broadcast_window(post_id: int, start_min: int, end_min: int):&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            bp = await session.get(BroadcastPost, post_id, with_for_update=True)&#10;            if not bp:&#10;                return False&#10;            bp.active_start_min = start_min&#10;            bp.active_end_min = end_min&#10;            session.add(bp)&#10;        await session.commit()&#10;    return True&#10;&#10;&#10;async def get_broadcast(post_id: int):&#10;    async with async_session() as session:&#10;        return await session.get(BroadcastPost, post_id)&#10;&#10;&#10;async def list_broadcasts(active_only: bool = False):&#10;    async with async_session() as session:&#10;        if active_only:&#10;            posts = await session.scalars(select(BroadcastPost).where(BroadcastPost.is_active == True))&#10;        else:&#10;            posts = await session.scalars(select(BroadcastPost))&#10;        return posts.all()&#10;&#10;&#10;async def get_broadcast_config():&#10;    async with async_session() as session:&#10;        cfg = await session.scalar(select(BroadcastConfig).limit(1))&#10;        return cfg&#10;&#10;&#10;async def upsert_broadcast_config(enabled: bool, start_min: int | None = None, end_min: int | None = None):&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            cfg = await session.scalar(select(BroadcastConfig).limit(1).with_for_update())&#10;            if not cfg:&#10;                cfg = BroadcastConfig(&#10;                    enabled=enabled,&#10;                    active_start_min=start_min if start_min is not None else 9*60,&#10;                    active_end_min=end_min if end_min is not None else 23*60&#10;                )&#10;                session.add(cfg)&#10;            else:&#10;                cfg.enabled = enabled&#10;                if start_min is not None:&#10;                    cfg.active_start_min = start_min&#10;                if end_min is not None:&#10;                    cfg.active_end_min = end_min&#10;                session.add(cfg)&#10;        await session.commit()&#10;    return True&#10;" />
              <option name="updatedContent" value="import os&#10;from datetime import datetime&#10;from sqlalchemy import select&#10;from app.database.models import async_session, PendingPost, ScheduledPost, LastMessage, PostIsPinned, BroadcastPost, BroadcastConfig&#10;&#10;&#10;async def get_pin_info(post_id: int):&#10;    async with async_session() as session:&#10;        existing = await session.scalar(select(PostIsPinned).where(PostIsPinned.post_id == post_id))&#10;        return existing.pinned if existing else False&#10;&#10;&#10;async def set_pin_info(post_id: int, pinned: bool):&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            existing = await session.scalar(select(PostIsPinned).where(PostIsPinned.post_id == post_id).with_for_update())&#10;            if existing:&#10;                existing.pinned = pinned&#10;                session.add(existing)&#10;            else:&#10;                session.add(PostIsPinned(post_id=post_id, pinned=pinned))&#10;        await session.commit()&#10;&#10;&#10;async def get_last_message_time():&#10;    async with async_session() as session:&#10;        messages = await session.scalars(select(LastMessage))&#10;        res = [[msg.id, msg.time] for msg in messages]&#10;        await session.commit()&#10;        return None if not res else max(res)[1]&#10;&#10;&#10;async def add_last_message_time(time):&#10;    async with async_session() as session:&#10;        session.add(LastMessage(time=time))&#10;        await session.commit()&#10;&#10;&#10;async def delete_last_messages():&#10;    async with async_session() as session:&#10;        await session.delete(LastMessage)&#10;        await session.commit()&#10;&#10;&#10;async def add_or_update_pending_post(content_type: str, text: str, photo_file_ids: list[str], media_group_id: int = 0, chat_id: int | None = None):&#10;    post = PendingPost(&#10;        content_type=content_type,&#10;        text=text,&#10;        photo_file_ids=photo_file_ids,&#10;        media_group_id=media_group_id if media_group_id else 0,&#10;        chat_id=chat_id or int(os.getenv('MAIN_CHAT_ID', 0))&#10;    )&#10;&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            # Проверяем существование с lock (with_for_update)&#10;            existing = await session.scalar(&#10;                select(PendingPost)&#10;                .where(PendingPost.media_group_id == post.media_group_id,&#10;                       PendingPost.media_group_id != 0)&#10;                .with_for_update()&#10;            )&#10;            if existing:&#10;                # Обновляем существующий: добавляем новые file_ids&#10;                existing.photo_file_ids.extend(photo_file_ids)&#10;                existing.text = text or existing.text  # Сохраняем caption, если новый&#10;                if chat_id:&#10;                    existing.chat_id = chat_id&#10;                session.add(existing)&#10;            else:&#10;                session.add(post)&#10;        await session.commit()&#10;&#10;&#10;async def get_pending_posts():&#10;    async with async_session() as session:&#10;        posts = await session.scalars(select(PendingPost))&#10;        return posts.all()&#10;&#10;&#10;async def delete_pending_post(post_id: int):&#10;    async with async_session() as session:&#10;        post = await session.get(PendingPost, post_id)&#10;        if post:&#10;            await session.delete(post)&#10;            await session.commit()&#10;            return True&#10;        return False&#10;&#10;&#10;async def add_or_update_scheduled_post(&#10;    content_type: str,&#10;    text: str | None = None,&#10;    photo_file_ids: list[str] | None = None,&#10;    scheduled_time: datetime | None = None,&#10;    media_group_id: int = 0,&#10;    is_published: bool = False,&#10;    message_ids: list | None = None,&#10;    unpin_time: datetime | None = None,&#10;    delete_time: datetime | None = None,&#10;    post_id: int = 0,&#10;    chat_id: int | None = None&#10;):&#10;    if message_ids is None:&#10;        message_ids = []&#10;    if not photo_file_ids:&#10;        photo_file_ids = []&#10;    post = ScheduledPost(&#10;        content_type=content_type,&#10;        text=text,&#10;        photo_file_ids=photo_file_ids.copy(),  # копируем список во избежание мутации аргумента&#10;        scheduled_time=scheduled_time,&#10;        media_group_id=media_group_id or 0,&#10;        is_published=is_published,&#10;        message_ids=message_ids.copy(),&#10;        unpin_time=unpin_time,&#10;        delete_time=delete_time,&#10;        chat_id=chat_id or int(os.getenv('MAIN_CHAT_ID', 0))&#10;    )&#10;&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            existing = await session.scalar(&#10;                select(ScheduledPost)&#10;                .where(&#10;                    ScheduledPost.id == post_id&#10;                )&#10;                .with_for_update()&#10;            )&#10;            if existing:&#10;                # Обновляем список photo_file_ids, добавляя новые уникальные элементы&#10;                updated_ids = existing.photo_file_ids or []&#10;                if photo_file_ids:&#10;                    for pid in photo_file_ids:&#10;                        if pid not in updated_ids:&#10;                            updated_ids.append(pid)&#10;                existing.photo_file_ids = updated_ids or existing.photo_file_ids&#10;&#10;                # Обновляем другие поля, если переданы значения&#10;&#10;                existing.text = text or existing.text&#10;                existing.scheduled_time = scheduled_time or existing.scheduled_time&#10;                existing.is_published = is_published&#10;                existing.message_ids = message_ids.copy() or existing.message_ids&#10;                existing.unpin_time = unpin_time or existing.unpin_time&#10;                existing.delete_time = delete_time or existing.delete_time&#10;                existing.chat_id = chat_id or existing.chat_id&#10;&#10;                session.add(existing)&#10;            else:&#10;                session.add(post)&#10;&#10;        await session.commit()&#10;&#10;&#10;async def get_scheduled_post(post_id: int):&#10;    async with async_session() as session:&#10;        post = await session.scalar(select(ScheduledPost).where(ScheduledPost.id == post_id))&#10;        return post&#10;&#10;&#10;async def get_scheduled_posts():&#10;    async with async_session() as session:&#10;        posts = await session.scalars(select(ScheduledPost))&#10;        return posts.all()&#10;&#10;&#10;async def delete_scheduled_post(post_id: int):&#10;    async with async_session() as session:&#10;        post = await session.get(ScheduledPost, post_id)&#10;        if post:&#10;            await session.delete(post)&#10;            await session.commit()&#10;            return True&#10;        return False&#10;&#10;&#10;async def add_broadcast_post(&#10;    content_type: str,&#10;    text: str | None,&#10;    photo_file_ids: list[str] | None,&#10;    media_group_id: int,&#10;    next_run_time: datetime,&#10;    end_time: datetime,&#10;    interval_minutes: int,&#10;    chat_id: int,&#10;    mode: str = 'full',&#10;    active_start_min: int | None = None,&#10;    active_end_min: int | None = None&#10;):&#10;    if not photo_file_ids:&#10;        photo_file_ids = []&#10;    if mode not in ('full', 'limited'):&#10;        mode = 'full'&#10;&#10;    # Ограничение длины текста как у обычной публикации&#10;    if text:&#10;        max_len = 1024 if photo_file_ids else 4096&#10;        if len(text) &gt; max_len:&#10;            text = text[:max_len]&#10;&#10;    # Если окно не передано — пробуем взять глобальное&#10;    if mode == 'limited':&#10;        if active_start_min is None or active_end_min is None:&#10;            cfg = await get_broadcast_config()&#10;            if cfg and cfg.enabled:&#10;                active_start_min = cfg.active_start_min&#10;                active_end_min = cfg.active_end_min&#10;            else:&#10;                # если глобальная конфигурация выключена — fallback в full&#10;                mode = 'full'&#10;&#10;    post = BroadcastPost(&#10;        content_type=content_type,&#10;        text=text,&#10;        photo_file_ids=photo_file_ids.copy(),&#10;        media_group_id=media_group_id or 0,&#10;        next_run_time=next_run_time,&#10;        end_time=end_time,&#10;        interval_minutes=interval_minutes,&#10;        chat_id=chat_id,&#10;        is_active=True,&#10;        mode=mode,&#10;        active_start_min=active_start_min if active_start_min is not None else 9*60,&#10;        active_end_min=active_end_min if active_end_min is not None else 23*60&#10;    )&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            session.add(post)&#10;        await session.commit()&#10;    return post&#10;&#10;&#10;async def get_active_broadcast_posts():&#10;    async with async_session() as session:&#10;        posts = await session.scalars(select(BroadcastPost).where(BroadcastPost.is_active == True))&#10;        return posts.all()&#10;&#10;&#10;async def update_broadcast_run(post_id: int, next_run_time: datetime | None, last_run_time: datetime, deactivate: bool = False):&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            bp = await session.get(BroadcastPost, post_id, with_for_update=True)&#10;            if not bp:&#10;                return False&#10;            bp.last_run_time = last_run_time&#10;            if deactivate:&#10;                bp.is_active = False&#10;            else:&#10;                bp.next_run_time = next_run_time&#10;            session.add(bp)&#10;        await session.commit()&#10;    return True&#10;&#10;&#10;async def stop_broadcast(post_id: int):&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            bp = await session.get(BroadcastPost, post_id, with_for_update=True)&#10;            if not bp:&#10;                return False&#10;            bp.is_active = False&#10;            session.add(bp)&#10;        await session.commit()&#10;    return True&#10;&#10;&#10;async def set_broadcast_mode(post_id: int, mode: str):&#10;    if mode not in ('full', 'limited'):&#10;        return False&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            bp = await session.get(BroadcastPost, post_id, with_for_update=True)&#10;            if not bp:&#10;                return False&#10;            bp.mode = mode&#10;            session.add(bp)&#10;        await session.commit()&#10;    return True&#10;&#10;&#10;async def update_broadcast_window(post_id: int, start_min: int, end_min: int):&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            bp = await session.get(BroadcastPost, post_id, with_for_update=True)&#10;            if not bp:&#10;                return False&#10;            bp.active_start_min = start_min&#10;            bp.active_end_min = end_min&#10;            session.add(bp)&#10;        await session.commit()&#10;    return True&#10;&#10;&#10;async def get_broadcast(post_id: int):&#10;    async with async_session() as session:&#10;        return await session.get(BroadcastPost, post_id)&#10;&#10;&#10;async def list_broadcasts(active_only: bool = False):&#10;    async with async_session() as session:&#10;        if active_only:&#10;            posts = await session.scalars(select(BroadcastPost).where(BroadcastPost.is_active == True))&#10;        else:&#10;            posts = await session.scalars(select(BroadcastPost))&#10;        return posts.all()&#10;&#10;&#10;async def get_broadcast_config():&#10;    async with async_session() as session:&#10;        cfg = await session.scalar(select(BroadcastConfig).limit(1))&#10;        return cfg&#10;&#10;&#10;async def upsert_broadcast_config(enabled: bool, start_min: int | None = None, end_min: int | None = None):&#10;    async with async_session() as session:&#10;        async with session.begin():&#10;            cfg = await session.scalar(select(BroadcastConfig).limit(1).with_for_update())&#10;            if not cfg:&#10;                cfg = BroadcastConfig(&#10;                    enabled=enabled,&#10;                    active_start_min=start_min if start_min is not None else 9*60,&#10;                    active_end_min=end_min if end_min is not None else 23*60&#10;                )&#10;                session.add(cfg)&#10;            else:&#10;                cfg.enabled = enabled&#10;                if start_min is not None:&#10;                    cfg.active_start_min = start_min&#10;                if end_min is not None:&#10;                    cfg.active_end_min = end_min&#10;                session.add(cfg)&#10;        await session.commit()&#10;    return True" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/utils/scheduler.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/utils/scheduler.py" />
              <option name="originalContent" value="# utils/scheduler.py&#10;import logging&#10;import asyncio&#10;import os&#10;from datetime import datetime, timedelta&#10;import random&#10;from aiogram import Bot&#10;from aiogram.types import InputMediaPhoto&#10;from aiogram.exceptions import TelegramBadRequest  # NEW&#10;from app.database.requests import get_pending_posts, delete_pending_post, get_scheduled_posts, delete_scheduled_post, get_active_broadcast_posts, update_broadcast_run&#10;import app.database.requests as req&#10;import pytz&#10;from app.database.models import ScheduledPost, PendingPost&#10;from apscheduler.triggers.date import DateTrigger&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;async def handle_missed_tasks(bot: Bot, channel_id: int | str, scheduler):&#10;    msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;    now = datetime.now(msk_tz)&#10;    scheduled_posts = await get_scheduled_posts()  # Ваша функция для получения постов&#10;    for post in scheduled_posts:&#10;        if not post.is_published:&#10;            continue&#10;        # Безопасная локализация (используйте вашу функцию make_aware)&#10;        unpin_time = make_aware(post.unpin_time, msk_tz) if post.unpin_time else None&#10;        delete_time = make_aware(post.delete_time, msk_tz) if post.delete_time else None&#10;        msg = post.message_ids&#10;        is_pinned = await req.get_pin_info(post.message_ids[0]) if post.message_ids else False&#10;        target_chat = post.chat_id or channel_id&#10;        # Проверка и выполнение missed unpin&#10;        if unpin_time and now &gt;= unpin_time and is_pinned:  # Предполагаем поле is_unpinned в модели&#10;            try:&#10;                await unpin_after_duration(bot, target_chat, msg[0])  # Выполняем открепление&#10;                #await notification_admins(bot, os.getenv('NOTIFICATION_CHAT'), post, 'unpin')  # Уведомление&#10;                logger.info(f&quot;Performed missed unpin for post {post.id}&quot;)&#10;            except Exception as e:&#10;                logger.error(f&quot;Error performing missed unpin for post {post.id}: {e}&quot;)&#10;        # Проверка и выполнение missed delete&#10;        if delete_time and now &gt;= delete_time:  # Предполагаем поле is_deleted&#10;            try:&#10;                await bot.delete_messages(target_chat, msg)  # Удаление сообщений&#10;                await delete_scheduled_post(post.id)  # Удаление из БД&#10;                await notification_admins(bot, os.getenv('NOTIFICATION_CHAT'), post, 'delete')  # Уведомление&#10;                logger.info(f&quot;Performed missed delete for post {post.id}&quot;)&#10;            except Exception as e:&#10;                logger.error(f&quot;Error performing missed delete for post {post.id}: {e}&quot;)&#10;        # Если время не прошло, добавляем в scheduler как обычно&#10;        if (unpin_time and now &lt; unpin_time) or (delete_time and now &lt; delete_time):&#10;            await update_unpin_or_delete_task(bot, channel_id, scheduler)  # Ваша функция для добавления jobs&#10;&#10;&#10;def make_aware(dt: datetime, tz: pytz.timezone) -&gt; datetime | None:&#10;    if dt is None:&#10;        return None&#10;    if dt.tzinfo is None:&#10;        return tz.localize(dt)&#10;    else:&#10;        return dt.astimezone(tz)&#10;&#10;&#10;async def post_content(bot: Bot, chat_id: int, post: ScheduledPost | PendingPost, notification: bool = False):&#10;    # Если это уведомление — всегда шлём в указанный chat_id, иначе используем chat_id поста&#10;    target_chat = chat_id if notification else (getattr(post, 'chat_id', None) or chat_id)&#10;    text = str(getattr(post, 'text', '') or '')&#10;    # NEW: Проверка лимитов до отправки; если нарушены — не публикуем&#10;    try:&#10;        if post.content_type == 'text':&#10;            if len(text) &gt; 4096:&#10;                logger.warning(f&quot;Skip publish: text too long ({len(text)} &gt; 4096). post_id={getattr(post, 'id', None)}&quot;)&#10;                # уведомление админам (если это не служебное уведомление)&#10;                notif_chat = os.getenv('NOTIFICATION_CHAT') or os.getenv('ADMIN_CHAT_ID')&#10;                if notif_chat and not notification:&#10;                    await bot.send_message(int(notif_chat), f&quot;Пост id={getattr(post, 'id', None)} не опубликован: превышен лимит 4096 символов.&quot;)&#10;                return&#10;            msg = await bot.send_message(target_chat, text)&#10;&#10;        elif post.content_type == 'photo' and post.photo_file_ids:&#10;            if len(text) &gt; 1024:&#10;                logger.warning(f&quot;Skip publish: caption too long ({len(text)} &gt; 1024). post_id={getattr(post, 'id', None)}&quot;)&#10;                notif_chat = os.getenv('NOTIFICATION_CHAT') or os.getenv('ADMIN_CHAT_ID')&#10;                if notif_chat and not notification:&#10;                    await bot.send_message(int(notif_chat), f&quot;Пост id={getattr(post, 'id', None)} не опубликован: превышен лимит 1024 символов для подписи.&quot;)&#10;                return&#10;            if len(post.photo_file_ids) == 1:&#10;                msg = await bot.send_photo(target_chat, post.photo_file_ids[0], caption=text or None)&#10;            else:&#10;                media = [InputMediaPhoto(media=file_id) for file_id in post.photo_file_ids]&#10;                if text:&#10;                    media[0].caption = text  # Caption только для первого&#10;                msg = await bot.send_media_group(target_chat, media)&#10;        else:&#10;            raise ValueError(&quot;Неверный тип контента&quot;)&#10;&#10;    except TelegramBadRequest as e:&#10;        logger.error(f&quot;TelegramBadRequest while posting content (post id={getattr(post, 'id', None)}): {e}&quot;)&#10;        try:&#10;            notif_chat = os.getenv('NOTIFICATION_CHAT') or os.getenv('ADMIN_CHAT_ID')&#10;            if notif_chat and not notification:&#10;                await bot.send_message(int(notif_chat), f&quot;Не удалось опубликовать пост id={getattr(post, 'id', None)}: {e}&quot;)&#10;        except Exception as e2:&#10;            logger.error(f&quot;Failed to notify about bad request: {e2}&quot;)&#10;        return&#10;    except Exception as e:&#10;        logger.exception(f&quot;Unexpected error while posting content (post id={getattr(post, 'id', None)}): {e}&quot;)&#10;        return&#10;&#10;    if not notification:&#10;        m = [msg] if type(msg) is not list else msg&#10;        if post.chat_id == int(os.getenv('MAIN_CHAT_ID')):&#10;            await req.add_last_message_time(datetime.now())&#10;        if isinstance(post, ScheduledPost):&#10;            await req.add_or_update_scheduled_post(&#10;                post.content_type,&#10;                is_published=True,&#10;                message_ids=[s.message_id for s in m],&#10;                post_id=post.id&#10;            )&#10;        return m&#10;&#10;&#10;async def unpin_after_duration(bot: Bot, chat_id: int, message_id: int):&#10;    try:&#10;        await bot.unpin_chat_message(chat_id, message_id=message_id)&#10;        await req.set_pin_info(message_id, False)&#10;    except Exception as e:&#10;        print(f&quot;Не удалось открепить сообщение {message_id} в чате {chat_id}: {e}&quot;)&#10;&#10;&#10;async def notification_admins(bot: Bot, chat_id: int | str, post: ScheduledPost, notification: str):&#10;    msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;    now = datetime.now(msk_tz)&#10;    text = f'id поста: {post.id}\n'&#10;    dct = {}&#10;    if post.unpin_time:&#10;        post.unpin_time = make_aware(post.unpin_time, msk_tz)&#10;        if now &gt;= post.unpin_time:&#10;            dct['unpin'] = f'Пост {post.id} был откреплён'&#10;        elif (post.unpin_time - now).days &lt;= 3:&#10;            dct['unpin'] = (f'Пост будет откреплён через 3 дня или менее: {post.unpin_time}\n'&#10;                            f'Изменить время открепления можно командой /pin_post, как её использовать указано в /help')&#10;&#10;    if post.delete_time:&#10;        post.delete_time = make_aware(post.delete_time, msk_tz)&#10;        if now &gt;= post.delete_time:&#10;            dct['delete'] = f'Пост был удалён'&#10;        elif (post.delete_time - now).days &lt;= 3:&#10;            dct['delete'] = (f'Пост будет удалён через 3 дня или менее: {post.delete_time}\n'&#10;                             f'После удаления из чата он также будет удалён из базы данных')&#10;&#10;    # Проверяем, есть ли соответствующее уведомление в словаре&#10;    if notification in dct:&#10;        await post_content(bot, chat_id, post, notification=True)&#10;        text += dct[notification]&#10;        await bot.send_message(chat_id, text=text)&#10;&#10;&#10;async def scheduler_task(bot: Bot, channel_id: int, scheduler):&#10;    msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;    now = datetime.now(msk_tz)&#10;&#10;    # Проверка запланированных постов&#10;    scheduled_posts = await get_scheduled_posts()&#10;    for post in scheduled_posts:&#10;        post.scheduled_time = make_aware(post.scheduled_time, msk_tz)&#10;        if post.scheduled_time &gt; now or post.is_published:&#10;            continue&#10;        await post_content(bot, post.chat_id or channel_id, post)&#10;        await asyncio.sleep(5)&#10;        await update_unpin_or_delete_task(bot, channel_id, scheduler)&#10;&#10;&#10;async def update_unpin_or_delete_task(bot: Bot, channel_id: int | str, scheduler):&#10;    msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;    now = datetime.now(msk_tz)&#10;    # Проверка запланированных постов&#10;    scheduled_posts = await get_scheduled_posts()&#10;    for post in scheduled_posts:&#10;        if not post.is_published:&#10;            continue&#10;        msg = post.message_ids&#10;        if not msg:&#10;            continue&#10;&#10;        unpin_time = make_aware(post.unpin_time, msk_tz) if post.unpin_time else None&#10;        delete_time = make_aware(post.delete_time, msk_tz) if post.delete_time else None&#10;&#10;        first_msg_id = msg[0]&#10;        is_pinned = await req.get_pin_info(first_msg_id)&#10;        target_chat = post.chat_id or channel_id&#10;        # 1) Пин разрешён ТОЛЬКО если время открепления ещё не наступило&#10;        if unpin_time and now &lt; unpin_time and not is_pinned:&#10;            try:&#10;                await bot.pin_chat_message(target_chat, first_msg_id, disable_notification=True)&#10;                await req.set_pin_info(first_msg_id, True)  # фиксируем только после успеха&#10;            except Exception as e:&#10;                logger.error(f&quot;Не удалось закрепить сообщение {first_msg_id}: {e}&quot;)&#10;&#10;        if unpin_time and now &lt; unpin_time:&#10;            try:&#10;                scheduler.add_job(&#10;                    notification_admins,&#10;                    trigger=DateTrigger(run_date=post.unpin_time-timedelta(days=2, hours=23)),&#10;                    args=[bot, os.getenv('NOTIFICATION_CHAT'), post, 'unpin'],&#10;                    id=f'notify_unpin_3_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;                scheduler.add_job(&#10;                    unpin_after_duration,&#10;                    trigger=DateTrigger(run_date=post.unpin_time),&#10;                    args=[bot, target_chat, msg[0]],&#10;                    id=f'unpin_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;                scheduler.add_job(&#10;                    notification_admins,&#10;                    trigger=DateTrigger(run_date=post.unpin_time),&#10;                    args=[bot, os.getenv('NOTIFICATION_CHAT'), post, 'unpin'],&#10;                    id=f'notify_unpin_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;            except Exception as e:&#10;                print(f&quot;Не удалось закрепить сообщение: {e}&quot;)&#10;        if delete_time and now &lt; delete_time:&#10;            try:&#10;                scheduler.add_job(&#10;                    notification_admins,&#10;                    trigger=DateTrigger(run_date=post.delete_time - timedelta(days=2, hours=23)),&#10;                    args=[bot, os.getenv('NOTIFICATION_CHAT'), post, 'delete'],&#10;                    id=f'notify_3_delete_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;                scheduler.add_job(&#10;                    bot.delete_messages,&#10;                    trigger=DateTrigger(run_date=post.delete_time),&#10;                    args=[target_chat, msg],&#10;                    id=f'delete_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;                scheduler.add_job(&#10;                    delete_scheduled_post,&#10;                    trigger=DateTrigger(run_date=post.delete_time),&#10;                    args=[post.id],&#10;                    id=f'delete_from_db_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;                scheduler.add_job(&#10;                    notification_admins,&#10;                    trigger=DateTrigger(run_date=post.delete_time),&#10;                    args=[bot, os.getenv('NOTIFICATION_CHAT'), post, 'delete'],&#10;                    id=f'notify_delete_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;            except Exception as e:&#10;                print(f'Не удалось запланировать удаление: {e}')&#10;&#10;&#10;async def pending_task(bot: Bot, channel_id: int):&#10;    msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;    now = datetime.now(msk_tz)&#10;&#10;    last_message_time = await req.get_last_message_time()&#10;    if last_message_time:&#10;        last_message_time = make_aware(last_message_time, msk_tz)&#10;    # Проверка низкой активности&#10;    if 11 &lt;= now.hour &lt; 23:&#10;        if last_message_time is None or (now - last_message_time) &gt; timedelta(hours=2):&#10;            delay = random.randint(6, 36)  # Задержка 1–60 минут&#10;            await asyncio.sleep(delay)&#10;        last_message_time = await req.get_last_message_time()&#10;        last_message_time = make_aware(last_message_time, msk_tz)&#10;        if last_message_time is None or (now - last_message_time) &gt; timedelta(hours=2):&#10;            pending_posts = await get_pending_posts()&#10;            if pending_posts:&#10;                post = random.choice(pending_posts)&#10;                await post_content(bot, getattr(post, 'chat_id', None) or channel_id, post)&#10;                await delete_pending_post(post.id)&#10;&#10;&#10;async def broadcast_task(bot: Bot, scheduler):&#10;    &quot;&quot;&quot;Рассылка broadcast-постов с поддержкой режимов full/limited и дневного окна.&#10;    Алгоритм:&#10;    - Берём активные кампании.&#10;    - Для каждой: если истёк end_time -&gt; деактивируем.&#10;    - Иначе догоняем отставание: вычисляем сколько интервалов пропущено.&#10;      Для режима limited публикация допускается только если время next_run попадает в окно активности.&#10;      Если нет — переносим next_run на ближайшее начало окна.&#10;    - Ограничение защиты от шторма: максимум 200 публикаций за один проход для кампании.&#10;    - Иначе догоняем отставание: вычисляем сколько интервалов пропущено.&#10;      Для режима limited публикация допускается только если время next_run попадает в окно активности.&#10;      Если нет — переносим next_run на ближайшее начало окна.&#10;    - Ограничение защиты от шторма: максимум 200 публикаций за один проход для кампании.&#10;    &quot;&quot;&quot;&#10;    from app.database.requests import get_active_broadcast_posts, update_broadcast_run, get_broadcast_config&#10;    try:&#10;        now = datetime.now(msk_tz)&#10;            # helper to localize&#10;        broadcasts = await get_active_broadcast_posts()&#10;        for bp in broadcasts:&#10;            # helper to localize&#10;                if dt.tzinfo is None:&#10;                    return msk_tz.localize(dt)&#10;                return dt.astimezone(msk_tz)&#10;                    return True&#10;                mins = dt.hour * 60 + dt.minute&#10;                if start_min &lt;= end_min:&#10;                    return start_min &lt;= mins &lt; end_min&#10;            # Функция: сдвинуть dt к ближайшему началу окна если вне окна&#10;                await update_broadcast_run(bp.id, None, last_run_time=now.replace(tzinfo=None), deactivate=True)&#10;                # текущий день&#10;            # Параметры окна&#10;                if dt &lt; candidate:&#10;            start_min = getattr(bp, 'active_start_min', 9*60)&#10;            end_min = getattr(bp, 'active_end_min', 23*60)&#10;            # Если режим limited и глобальная конфигурация выключена (enabled=False), трактуем как full&#10;                return candidate + timedelta(days=1)&#10;            # Если первая публикация ещё не в окне — подравниваем но не считаем публикацией&#10;            # Функция проверки окна&#10;            def in_window(dt: datetime):&#10;                if mode != 'limited':&#10;                    return True&#10;                mins = dt.hour * 60 + dt.minute&#10;                if start_min &lt;= end_min:&#10;                    return start_min &lt;= mins &lt; end_min&#10;                # Ночной пролёт через полночь (редкий сценарий)&#10;                return mins &gt;= start_min or mins &lt; end_min&#10;            # Функция: сдвинуть dt к ближайшему началу окна если вне окна&#10;            def align_to_window(dt: datetime):&#10;                if mode != 'limited':&#10;                    return dt&#10;                if in_window(dt):&#10;                    return dt&#10;                # вычисляем локальную дату и строим точку старта окна&#10;                # текущий день&#10;                day_start = dt.replace(hour=0, minute=0, second=0, microsecond=0)&#10;                candidate = day_start + timedelta(minutes=start_min)&#10;                if dt &lt; candidate:&#10;                    return candidate&#10;                # если уже после окна — перенос на следующий день начало окна&#10;                return candidate + timedelta(days=1)&#10;            # Если первая публикация ещё не в окне — подравниваем но не считаем публикацией&#10;            if not in_window(next_run):&#10;                aligned = align_to_window(next_run)&#10;                if aligned &gt; end_time:&#10;                    await update_broadcast_run(bp.id, None, last_run_time=now.replace(tzinfo=None), deactivate=True)&#10;                    continue&#10;                await update_broadcast_run(bp.id, aligned.replace(tzinfo=None), last_run_time=(bp.last_run_time or next_run).replace(tzinfo=None))&#10;                continue&#10;                aligned = align_to_window(next_run)&#10;            # Вычисляем сколько интервалов пропущено (если next_run &lt;&lt; now)&#10;            if now &gt; next_run:&#10;                diff = now - next_run&#10;                missed = int(diff // interval)&#10;            else:&#10;                missed = 0&#10;            # Публикуем пока next_run &lt;= now (catch-up) плюс одна текущая если ровно совпало&#10;            iterations = 0&#10;            max_iterations = 200  # защита&#10;            while next_run &lt;= now and next_run &lt;= end_time and iterations &lt; max_iterations:&#10;                if not in_window(next_run):&#10;                    # перенос в окно и выходим из цикла catch-up (дальнейшие публикации позже)&#10;                    next_run = align_to_window(next_run)&#10;                    break&#10;                # Формируем временный объект&#10;                    # перенос в окно и выходим из цикла catch-up (дальнейшие публикации позже)&#10;                    next_run = align_to_window(next_run)&#10;                    break&#10;                # Формируем временный объект&#10;                class _Tmp:&#10;                    pass&#10;                tmp = _Tmp()&#10;                tmp.content_type = bp.content_type&#10;                tmp.photo_file_ids = bp.photo_file_ids or []&#10;                tmp.chat_id = bp.chat_id&#10;                tmp.id = f&quot;broadcast:{bp.id}&quot;&#10;                try:&#10;                    break&#10;                last_run_time = next_run&#10;                # Следующее время&#10;                next_run = next_run + interval&#10;                # Выравниваем для limited если вне окна&#10;                if not in_window(next_run):&#10;                    next_run = align_to_window(next_run)&#10;                iterations += 1&#10;                if next_run &gt; end_time:&#10;                    await update_broadcast_run(bp.id, None, last_run_time=last_run_time.replace(tzinfo=None), deactivate=True)&#10;                    break&#10;                        bp.id,&#10;                # Если цикл завершился без деактивации&#10;                if next_run &lt;= end_time:&#10;                    await update_broadcast_run(&#10;                        bp.id,&#10;                        next_run.replace(tzinfo=None),&#10;                        last_run_time=(last_run_time if 'last_run_time' in locals() else (bp.last_run_time or next_run)).replace(tzinfo=None),&#10;                        deactivate=False&#10;                    )&#10;" />
              <option name="updatedContent" value="# utils/scheduler.py&#10;import logging&#10;import asyncio&#10;import os&#10;from datetime import datetime, timedelta&#10;import random&#10;from aiogram import Bot&#10;from aiogram.types import InputMediaPhoto&#10;from aiogram.exceptions import TelegramBadRequest  # NEW&#10;from app.database.requests import get_pending_posts, delete_pending_post, get_scheduled_posts, delete_scheduled_post, get_active_broadcast_posts, update_broadcast_run&#10;import app.database.requests as req&#10;import pytz&#10;from app.database.models import ScheduledPost, PendingPost&#10;from apscheduler.triggers.date import DateTrigger&#10;&#10;logging.basicConfig(level=logging.INFO)&#10;logger = logging.getLogger(__name__)&#10;&#10;&#10;async def handle_missed_tasks(bot: Bot, channel_id: int | str, scheduler):&#10;    msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;    now = datetime.now(msk_tz)&#10;    scheduled_posts = await get_scheduled_posts()  # Ваша функция для получения постов&#10;    for post in scheduled_posts:&#10;        if not post.is_published:&#10;            continue&#10;        # Безопасная локализация (используйте вашу функцию make_aware)&#10;        unpin_time = make_aware(post.unpin_time, msk_tz) if post.unpin_time else None&#10;        delete_time = make_aware(post.delete_time, msk_tz) if post.delete_time else None&#10;        msg = post.message_ids&#10;        is_pinned = await req.get_pin_info(post.message_ids[0]) if post.message_ids else False&#10;        target_chat = post.chat_id or channel_id&#10;        # Проверка и выполнение missed unpin&#10;        if unpin_time and now &gt;= unpin_time and is_pinned:  # Предполагаем поле is_unpinned в модели&#10;            try:&#10;                await unpin_after_duration(bot, target_chat, msg[0])  # Выполняем открепление&#10;                #await notification_admins(bot, os.getenv('NOTIFICATION_CHAT'), post, 'unpin')  # Уведомление&#10;                logger.info(f&quot;Performed missed unpin for post {post.id}&quot;)&#10;            except Exception as e:&#10;                logger.error(f&quot;Error performing missed unpin for post {post.id}: {e}&quot;)&#10;        # Проверка и выполнение missed delete&#10;        if delete_time and now &gt;= delete_time:  # Предполагаем поле is_deleted&#10;            try:&#10;                await bot.delete_messages(target_chat, msg)  # Удаление сообщений&#10;                await delete_scheduled_post(post.id)  # Удаление из БД&#10;                await notification_admins(bot, os.getenv('NOTIFICATION_CHAT'), post, 'delete')  # Уведомление&#10;                logger.info(f&quot;Performed missed delete for post {post.id}&quot;)&#10;            except Exception as e:&#10;                logger.error(f&quot;Error performing missed delete for post {post.id}: {e}&quot;)&#10;        # Если время не прошло, добавляем в scheduler как обычно&#10;        if (unpin_time and now &lt; unpin_time) or (delete_time and now &lt; delete_time):&#10;            await update_unpin_or_delete_task(bot, channel_id, scheduler)  # Ваша функция для добавления jobs&#10;&#10;&#10;def make_aware(dt: datetime, tz: pytz.timezone) -&gt; datetime | None:&#10;    if dt is None:&#10;        return None&#10;    if dt.tzinfo is None:&#10;        return tz.localize(dt)&#10;    else:&#10;        return dt.astimezone(tz)&#10;&#10;&#10;async def post_content(bot: Bot, chat_id: int, post: ScheduledPost | PendingPost, notification: bool = False):&#10;    # Если это уведомление — всегда шлём в указанный chat_id, иначе используем chat_id поста&#10;    target_chat = chat_id if notification else (getattr(post, 'chat_id', None) or chat_id)&#10;    text = str(getattr(post, 'text', '') or '')&#10;    # NEW: Проверка лимитов до отправки; если нарушены — не публикуем&#10;    try:&#10;        if post.content_type == 'text':&#10;            if len(text) &gt; 4096:&#10;                logger.warning(f&quot;Skip publish: text too long ({len(text)} &gt; 4096). post_id={getattr(post, 'id', None)}&quot;)&#10;                # уведомление админам (если это не служебное уведомление)&#10;                notif_chat = os.getenv('NOTIFICATION_CHAT') or os.getenv('ADMIN_CHAT_ID')&#10;                if notif_chat and not notification:&#10;                    await bot.send_message(int(notif_chat), f&quot;Пост id={getattr(post, 'id', None)} не опубликован: превышен лимит 4096 символов.&quot;)&#10;                return&#10;            msg = await bot.send_message(target_chat, text)&#10;&#10;        elif post.content_type == 'photo' and post.photo_file_ids:&#10;            if len(text) &gt; 1024:&#10;                logger.warning(f&quot;Skip publish: caption too long ({len(text)} &gt; 1024). post_id={getattr(post, 'id', None)}&quot;)&#10;                notif_chat = os.getenv('NOTIFICATION_CHAT') or os.getenv('ADMIN_CHAT_ID')&#10;                if notif_chat and not notification:&#10;                    await bot.send_message(int(notif_chat), f&quot;Пост id={getattr(post, 'id', None)} не опубликован: превышен лимит 1024 символов для подписи.&quot;)&#10;                return&#10;            if len(post.photo_file_ids) == 1:&#10;                msg = await bot.send_photo(target_chat, post.photo_file_ids[0], caption=text or None)&#10;            else:&#10;                media = [InputMediaPhoto(media=file_id) for file_id in post.photo_file_ids]&#10;                if text:&#10;                    media[0].caption = text  # Caption только для первого&#10;                msg = await bot.send_media_group(target_chat, media)&#10;        else:&#10;            raise ValueError(&quot;Неверный тип контента&quot;)&#10;&#10;    except TelegramBadRequest as e:&#10;        logger.error(f&quot;TelegramBadRequest while posting content (post id={getattr(post, 'id', None)}): {e}&quot;)&#10;        try:&#10;            notif_chat = os.getenv('NOTIFICATION_CHAT') or os.getenv('ADMIN_CHAT_ID')&#10;            if notif_chat and not notification:&#10;                await bot.send_message(int(notif_chat), f&quot;Не удалось опубликовать пост id={getattr(post, 'id', None)}: {e}&quot;)&#10;        except Exception as e2:&#10;            logger.error(f&quot;Failed to notify about bad request: {e2}&quot;)&#10;        return&#10;    except Exception as e:&#10;        logger.exception(f&quot;Unexpected error while posting content (post id={getattr(post, 'id', None)}): {e}&quot;)&#10;        return&#10;&#10;    if not notification:&#10;        m = [msg] if type(msg) is not list else msg&#10;        if post.chat_id == int(os.getenv('MAIN_CHAT_ID')):&#10;            await req.add_last_message_time(datetime.now())&#10;        if isinstance(post, ScheduledPost):&#10;            await req.add_or_update_scheduled_post(&#10;                post.content_type,&#10;                is_published=True,&#10;                message_ids=[s.message_id for s in m],&#10;                post_id=post.id&#10;            )&#10;        return m&#10;&#10;&#10;async def unpin_after_duration(bot: Bot, chat_id: int, message_id: int):&#10;    try:&#10;        await bot.unpin_chat_message(chat_id, message_id=message_id)&#10;        await req.set_pin_info(message_id, False)&#10;    except Exception as e:&#10;        print(f&quot;Не удалось открепить сообщение {message_id} в чате {chat_id}: {e}&quot;)&#10;&#10;&#10;async def notification_admins(bot: Bot, chat_id: int | str, post: ScheduledPost, notification: str):&#10;    msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;    now = datetime.now(msk_tz)&#10;    text = f'id поста: {post.id}\n'&#10;    dct = {}&#10;    if post.unpin_time:&#10;        post.unpin_time = make_aware(post.unpin_time, msk_tz)&#10;        if now &gt;= post.unpin_time:&#10;            dct['unpin'] = f'Пост {post.id} был откреплён'&#10;        elif (post.unpin_time - now).days &lt;= 3:&#10;            dct['unpin'] = (f'Пост будет откреплён через 3 дня или менее: {post.unpin_time}\n'&#10;                            f'Изменить время открепления можно командой /pin_post, как её использовать указано в /help')&#10;&#10;    if post.delete_time:&#10;        post.delete_time = make_aware(post.delete_time, msk_tz)&#10;        if now &gt;= post.delete_time:&#10;            dct['delete'] = f'Пост был удалён'&#10;        elif (post.delete_time - now).days &lt;= 3:&#10;            dct['delete'] = (f'Пост будет удалён через 3 дня или менее: {post.delete_time}\n'&#10;                             f'После удаления из чата он также будет удалён из базы данных')&#10;&#10;    # Проверяем, есть ли соответствующее уведомление в словаре&#10;    if notification in dct:&#10;        await post_content(bot, chat_id, post, notification=True)&#10;        text += dct[notification]&#10;        await bot.send_message(chat_id, text=text)&#10;&#10;&#10;async def scheduler_task(bot: Bot, channel_id: int, scheduler):&#10;    msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;    now = datetime.now(msk_tz)&#10;&#10;    # Проверка запланированных постов&#10;    scheduled_posts = await get_scheduled_posts()&#10;    for post in scheduled_posts:&#10;        post.scheduled_time = make_aware(post.scheduled_time, msk_tz)&#10;        if post.scheduled_time &gt; now or post.is_published:&#10;            continue&#10;        await post_content(bot, post.chat_id or channel_id, post)&#10;        await asyncio.sleep(5)&#10;        await update_unpin_or_delete_task(bot, channel_id, scheduler)&#10;&#10;&#10;async def update_unpin_or_delete_task(bot: Bot, channel_id: int | str, scheduler):&#10;    msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;    now = datetime.now(msk_tz)&#10;    # Проверка запланированных постов&#10;    scheduled_posts = await get_scheduled_posts()&#10;    for post in scheduled_posts:&#10;        if not post.is_published:&#10;            continue&#10;        msg = post.message_ids&#10;        if not msg:&#10;            continue&#10;&#10;        unpin_time = make_aware(post.unpin_time, msk_tz) if post.unpin_time else None&#10;        delete_time = make_aware(post.delete_time, msk_tz) if post.delete_time else None&#10;&#10;        first_msg_id = msg[0]&#10;        is_pinned = await req.get_pin_info(first_msg_id)&#10;        target_chat = post.chat_id or channel_id&#10;        # 1) Пин разрешён ТОЛЬКО если время открепления ещё не наступило&#10;        if unpin_time and now &lt; unpin_time and not is_pinned:&#10;            try:&#10;                await bot.pin_chat_message(target_chat, first_msg_id, disable_notification=True)&#10;                await req.set_pin_info(first_msg_id, True)  # фиксируем только после успеха&#10;            except Exception as e:&#10;                logger.error(f&quot;Не удалось закрепить сообщение {first_msg_id}: {e}&quot;)&#10;&#10;        if unpin_time and now &lt; unpin_time:&#10;            try:&#10;                scheduler.add_job(&#10;                    notification_admins,&#10;                    trigger=DateTrigger(run_date=post.unpin_time-timedelta(days=2, hours=23)),&#10;                    args=[bot, os.getenv('NOTIFICATION_CHAT'), post, 'unpin'],&#10;                    id=f'notify_unpin_3_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;                scheduler.add_job(&#10;                    unpin_after_duration,&#10;                    trigger=DateTrigger(run_date=post.unpin_time),&#10;                    args=[bot, target_chat, msg[0]],&#10;                    id=f'unpin_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;                scheduler.add_job(&#10;                    notification_admins,&#10;                    trigger=DateTrigger(run_date=post.unpin_time),&#10;                    args=[bot, os.getenv('NOTIFICATION_CHAT'), post, 'unpin'],&#10;                    id=f'notify_unpin_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;            except Exception as e:&#10;                print(f&quot;Не удалось закрепить сообщение: {e}&quot;)&#10;        if delete_time and now &lt; delete_time:&#10;            try:&#10;                scheduler.add_job(&#10;                    notification_admins,&#10;                    trigger=DateTrigger(run_date=post.delete_time - timedelta(days=2, hours=23)),&#10;                    args=[bot, os.getenv('NOTIFICATION_CHAT'), post, 'delete'],&#10;                    id=f'notify_3_delete_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;                scheduler.add_job(&#10;                    bot.delete_messages,&#10;                    trigger=DateTrigger(run_date=post.delete_time),&#10;                    args=[target_chat, msg],&#10;                    id=f'delete_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;                scheduler.add_job(&#10;                    delete_scheduled_post,&#10;                    trigger=DateTrigger(run_date=post.delete_time),&#10;                    args=[post.id],&#10;                    id=f'delete_from_db_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;                scheduler.add_job(&#10;                    notification_admins,&#10;                    trigger=DateTrigger(run_date=post.delete_time),&#10;                    args=[bot, os.getenv('NOTIFICATION_CHAT'), post, 'delete'],&#10;                    id=f'notify_delete_{post.id}',&#10;                    replace_existing=True&#10;                )&#10;            except Exception as e:&#10;                print(f'Не удалось запланировать удаление: {e}')&#10;&#10;&#10;async def pending_task(bot: Bot, channel_id: int):&#10;    msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;    now = datetime.now(msk_tz)&#10;&#10;    last_message_time = await req.get_last_message_time()&#10;    if last_message_time:&#10;        last_message_time = make_aware(last_message_time, msk_tz)&#10;    # Проверка низкой активности&#10;    if 11 &lt;= now.hour &lt; 23:&#10;        if last_message_time is None or (now - last_message_time) &gt; timedelta(hours=2):&#10;            delay = random.randint(6, 36)  # Задержка 1–60 минут&#10;            await asyncio.sleep(delay)&#10;        last_message_time = await req.get_last_message_time()&#10;        last_message_time = make_aware(last_message_time, msk_tz)&#10;        if last_message_time is None or (now - last_message_time) &gt; timedelta(hours=2):&#10;            pending_posts = await get_pending_posts()&#10;            if pending_posts:&#10;                post = random.choice(pending_posts)&#10;                await post_content(bot, getattr(post, 'chat_id', None) or channel_id, post)&#10;                await delete_pending_post(post.id)&#10;&#10;&#10;async def broadcast_task(bot: Bot, scheduler):&#10;    &quot;&quot;&quot;Рассылка broadcast-постов без «догоняющей» публикации:&#10;    - За один проход публикуется максимум одно сообщение на кампанию.&#10;    - Если режим limited и сейчас вне окна — переносим next_run_time на ближайшее начало окна (без публикации).&#10;    - После публикации переносим next_run_time в будущее (с учётом окна).&#10;    &quot;&quot;&quot;&#10;    from app.database.requests import get_active_broadcast_posts, update_broadcast_run, get_broadcast_config&#10;    try:&#10;        msk_tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;        now = datetime.now(msk_tz)&#10;        cfg = await get_broadcast_config()&#10;        broadcasts = await get_active_broadcast_posts()&#10;&#10;        for bp in broadcasts:&#10;            # Helpers&#10;            def aware(dt):&#10;                if dt is None:&#10;                    return None&#10;                return msk_tz.localize(dt) if dt.tzinfo is None else dt.astimezone(msk_tz)&#10;&#10;            def in_window(dt: datetime, mode: str, start_min: int, end_min: int) -&gt; bool:&#10;                if mode != 'limited':&#10;                    return True&#10;                mins = dt.hour * 60 + dt.minute&#10;                if start_min &lt;= end_min:&#10;                    return start_min &lt;= mins &lt; end_min&#10;                # окно через полночь&#10;                return mins &gt;= start_min or mins &lt; end_min&#10;&#10;            def next_window_start_from(ref: datetime, mode: str, start_min: int, end_min: int) -&gt; datetime:&#10;                if mode != 'limited':&#10;                    return ref&#10;                day_start = ref.replace(hour=0, minute=0, second=0, microsecond=0)&#10;                start_today = day_start + timedelta(minutes=start_min)&#10;                end_today = day_start + timedelta(minutes=end_min)&#10;                if ref &lt; start_today:&#10;                    return start_today&#10;                if ref &gt;= end_today:&#10;                    return start_today + timedelta(days=1)&#10;                return ref  # внутри окна&#10;&#10;            next_run = aware(bp.next_run_time)&#10;            end_time = aware(bp.end_time)&#10;            if not next_run or not end_time:&#10;                continue&#10;&#10;            # Деактивируем, если кампания завершилась&#10;            if now &gt; end_time:&#10;                await update_broadcast_run(&#10;                    bp.id,&#10;                    next_run_time=None,&#10;                    last_run_time=(aware(bp.last_run_time) or now).replace(tzinfo=None),&#10;                    deactivate=True&#10;                )&#10;                continue&#10;&#10;            # Параметры режима/окна&#10;            mode = getattr(bp, 'mode', 'full') or 'full'&#10;            start_min = getattr(bp, 'active_start_min', 9 * 60)&#10;            end_min = getattr(bp, 'active_end_min', 23 * 60)&#10;            if mode == 'limited' and cfg and not cfg.enabled:&#10;                mode = 'full'&#10;&#10;            interval = timedelta(minutes=bp.interval_minutes)&#10;&#10;            # Если пора публиковать (или мы «опоздали»), решаем, публиковать ли сейчас&#10;            if next_run &lt;= now:&#10;                # В limited вне окна — перенос на ближайшее окно, публикации нет&#10;                if not in_window(now, mode, start_min, end_min):&#10;                    new_next = next_window_start_from(now, mode, start_min, end_min)&#10;                    if new_next &gt; end_time:&#10;                        await update_broadcast_run(&#10;                            bp.id, None, last_run_time=(aware(bp.last_run_time) or now).replace(tzinfo=None), deactivate=True&#10;                        )&#10;                    else:&#10;                        await update_broadcast_run(&#10;                            bp.id, new_next.replace(tzinfo=None), last_run_time=(aware(bp.last_run_time) or now).replace(tzinfo=None)&#10;                        )&#10;                    continue&#10;&#10;                # Публикуем ОДИН раз&#10;                class _Tmp:&#10;                    pass&#10;                tmp = _Tmp()&#10;                tmp.content_type = bp.content_type&#10;                tmp.text = bp.text&#10;                tmp.photo_file_ids = bp.photo_file_ids or []&#10;                tmp.chat_id = bp.chat_id&#10;                tmp.id = f&quot;broadcast:{bp.id}&quot;&#10;&#10;                try:&#10;                    await post_content(bot, bp.chat_id, tmp)&#10;                except Exception as e:&#10;                    logger.error(f&quot;Ошибка публикации broadcast {bp.id}: {e}&quot;)&#10;                    # Перенесём попытку на следующий интервал, чтобы не спамить&#10;                    new_next = next_window_start_from(now + interval, mode, start_min, end_min)&#10;                    if new_next &gt; end_time:&#10;                        await update_broadcast_run(bp.id, None, last_run_time=now.replace(tzinfo=None), deactivate=True)&#10;                    else:&#10;                        await update_broadcast_run(bp.id, new_next.replace(tzinfo=None), last_run_time=now.replace(tzinfo=None))&#10;                    continue&#10;&#10;                # Обновляем next_run_time в будущее&#10;                new_next = now + interval&#10;                if not in_window(new_next, mode, start_min, end_min):&#10;                    new_next = next_window_start_from(new_next, mode, start_min, end_min)&#10;&#10;                if new_next &gt; end_time:&#10;                    await update_broadcast_run(bp.id, None, last_run_time=now.replace(tzinfo=None), deactivate=True)&#10;                else:&#10;                    await update_broadcast_run(bp.id, new_next.replace(tzinfo=None), last_run_time=now.replace(tzinfo=None))&#10;&#10;            else:&#10;                # Ещё не время. Если limited и next вне окна — аккуратно подтянем к ближайшему окну в будущем.&#10;                if not in_window(next_run, mode, start_min, end_min):&#10;                    aligned = next_window_start_from(next_run, mode, start_min, end_min)&#10;                    if aligned != next_run:&#10;                        if aligned &gt; end_time:&#10;                            await update_broadcast_run(&#10;                                bp.id, None, last_run_time=(aware(bp.last_run_time) or now).replace(tzinfo=None), deactivate=True&#10;                            )&#10;                        else:&#10;                            await update_broadcast_run(&#10;                                bp.id, aligned.replace(tzinfo=None), last_run_time=(aware(bp.last_run_time) or now).replace(tzinfo=None)&#10;                            )&#10;                # иначе просто ждём&#10;    except Exception as e:&#10;        logger.exception(f&quot;broadcast_task fatal error: {e}&quot;)" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>