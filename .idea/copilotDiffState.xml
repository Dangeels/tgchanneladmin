<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/handlers/menu.py">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/handlers/menu.py" />
              <option name="originalContent" value="import os&#10;from typing import Dict, List&#10;import uuid&#10;import dotenv&#10;from aiogram import Bot, F, Router&#10;from aiogram.enums import ParseMode&#10;from aiogram.filters import Command&#10;from aiogram.filters.callback_data import CallbackData&#10;from aiogram.fsm.context import FSMContext&#10;from aiogram.fsm.state import State, StatesGroup&#10;from aiogram.types import CallbackQuery, InlineKeyboardMarkup, InputMediaPhoto, Message, InlineKeyboardButton&#10;from aiogram.utils.keyboard import InlineKeyboardBuilder&#10;&#10;&#10;dotenv.load_dotenv()&#10;# Загружаем ID чатов из окружения&#10;ADMIN_CHAT_ID = int(os.getenv('ADMIN_CHAT_ID', '0'))&#10;NOTIFICATION_CHAT = int(os.getenv('NOTIFICATION_CHAT', str(ADMIN_CHAT_ID)))&#10;&#10;# Быстрые ссылки на наши площадки&#10;LINKS = {&#10;    'main': 'https://t.me/FreelanceSET',&#10;    'premium': 'https://t.me/VakansiiPREMIUM',&#10;    'free': 'https://t.me/freelanceFREEchat',&#10;    'reviews': 'https://t.me/PUSHfeedback',&#10;}&#10;&#10;ADMIN_CONTACT_URL = 'https://t.me/push_admin_Evgen'&#10;&#10;# Утилита: добавить кнопку «Связаться с админом» в самый низ клавиатуры&#10;def add_contact_button(builder: InlineKeyboardBuilder) -&gt; InlineKeyboardBuilder:&#10;    builder.row(InlineKeyboardButton(text='Связаться с админом', url=ADMIN_CONTACT_URL))&#10;    return builder&#10;&#10;# Global storage for pending orders&#10;pending_orders: Dict[str, Dict] = {}&#10;&#10;# Define FSM states for the purchase process&#10;class Purchase(StatesGroup):&#10;    waiting_check = State()  # Waiting for payment check photo&#10;    waiting_post = State()   # Waiting for the post text&#10;&#10;# Новый FSM для админа при отклонении&#10;class AdminReject(StatesGroup):&#10;    waiting_reason = State()&#10;&#10;# Define CallbackData factory for menu navigation&#10;class MenuCallback(CallbackData, prefix=&quot;menu&quot;):&#10;    level: str  # e.g., 'main', 'sub', 'extra', 'subextra', 'toggle', 'buy', 'cancel'&#10;    user_type: str = &quot;&quot;  # 'employer' or 'freelancer'&#10;    option: str = &quot;&quot;     # '1', '2', etc.&#10;    suboption: str = &quot;&quot;  # For extra options like 'pin', 'boost'&#10;    variant: str = &quot;&quot;    # For variants like '1_month', 'forever'&#10;    action: str = &quot;&quot;     # 'add' or 'remove' for toggle&#10;&#10;# Define CallbackData for admin actions&#10;class AdminCallback(CallbackData, prefix=&quot;admin&quot;):&#10;    action: str  # 'confirm' or 'reject'&#10;    order_id: str&#10;&#10;menu_router = Router()&#10;&#10;# Suboption names&#10;SUBOPTION_NAMES = {&#10;    &quot;pin&quot;: &quot;Закреп&quot;,&#10;    &quot;boost&quot;: &quot;Поднятие&quot;,&#10;}&#10;&#10;# Emoji for main options&#10;OPTION_EMOJIS = {&#10;    &quot;1&quot;: &quot;&quot;,&#10;    &quot;2&quot;: &quot;&quot;,&#10;    &quot;3&quot;: &quot;&quot;,&#10;    &quot;4&quot;: &quot;&quot;,&#10;    &quot;5&quot;: &quot;&quot;,&#10;    &quot;6&quot;: &quot;⭐&quot;&#10;}&#10;&#10;# Base prices (новый прайс)&#10;BASE_PRICES = {&#10;    &quot;employer&quot;: {&#10;        &quot;1&quot;: 0,          # Бесплатный чат — только закреп (без размещения)&#10;        &quot;2&quot;: 1600,       # Платный чат&#10;        &quot;3&quot;: 2400,       # Канал (премиум)&#10;        &quot;4&quot;: 2700,       # Пакет Стандарт&#10;        &quot;5&quot;: 3200,       # Пакет Стандарт + Закреп&#10;        &quot;6&quot;: 10000       # Пакет Премиум (оставлен как ранее)&#10;    },&#10;    &quot;freelancer&quot;: {&#10;        &quot;1&quot;: 0,          # Бесплатный чат — только закреп (без размещения)&#10;        &quot;2&quot;: 1200,       # Платный чат&#10;        &quot;3&quot;: 1500,       # Канал (премиум)&#10;        &quot;4&quot;: 1950,       # Пакет Стандарт&#10;        &quot;5&quot;: 2450,       # Пакет Стандарт + Закреп&#10;        &quot;6&quot;: 5000        # Пакет Премиум (оставлен как ранее)&#10;    }&#10;}&#10;&#10;# Descriptions с расширенным пояснением и ссылками&#10;DESCRIPTIONS = {&#10;    &quot;employer&quot;: {&#10;        &quot;1&quot;: (&#10;            &quot; Бесплатный чат — только закреп\n&quot;&#10;            &quot;• Публикация бесплатная, покупается только закреп в бесплатном чате.\n&quot;&#10;            &quot;• Закреп удерживает ваш пост вверху чата выбранный срок.\n&quot;&#10;            f&quot;• Ссылка на чат: {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;2&quot;: (&#10;            &quot; Стандарт (Платный чат) — 1600₽\n&quot;&#10;            &quot;• Размещение навсегда.\n&quot;&#10;            &quot;• Без закрепа по умолчанию. Можно добавить: Закреп и Поднятие.\n&quot;&#10;            f&quot;• Ссылка на чат: {LINKS['main']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;3&quot;: (&#10;            &quot; Канал (Премиум) — 2400₽\n&quot;&#10;            &quot;• Размещение навсегда.\n&quot;&#10;            &quot;• Без закрепа по умолчанию. Можно добавить: Закреп.\n&quot;&#10;            f&quot;• Ссылка на премиум-канал: {LINKS['premium']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;4&quot;: (&#10;            &quot; Пакет Стандарт — 2700₽ (вместо 4750₽)\n&quot;&#10;            &quot;• Основной чат (без закрепа).\n&quot;&#10;            &quot;• Премиум-канал (без закрепа).\n&quot;&#10;            &quot;• Закреп в бесплатном чате на 1 месяц.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;5&quot;: (&#10;            &quot; Пакет Стандарт + Закреп — 3200₽ (вместо 6000₽)\n&quot;&#10;            &quot;• Основной чат — с закрепом на 1 месяц.\n&quot;&#10;            &quot;• Премиум-канал — с закрепом на 1 месяц.\n&quot;&#10;            &quot;• Бесплатный чат — закреп на 1 месяц.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;6&quot;: (&#10;            &quot;⭐ Пакет Премиум\n&quot;&#10;            &quot;• Основной чат — закреп навсегда.\n&quot;&#10;            &quot;• Премиум-канал — закреп навсегда.\n&quot;&#10;            &quot;• Бесплатный чат — закреп навсегда.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        )&#10;    },&#10;    &quot;freelancer&quot;: {&#10;        &quot;1&quot;: (&#10;            &quot; Бесплатный чат — только закреп\n&quot;&#10;            &quot;• Публикация бесплатная, покупается только закреп в бесплатном чате.\n&quot;&#10;            &quot;• Закреп удерживает ваш пост вверху чата выбранный срок.\n&quot;&#10;            f&quot;• Ссылка на чат: {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;2&quot;: (&#10;            &quot; Стандарт (Платный чат) — 1200₽\n&quot;&#10;            &quot;• Размещение навсегда.\n&quot;&#10;            &quot;• Без закрепа по умолчанию. Можно добавить: Закреп и Поднятие.\n&quot;&#10;            f&quot;• Ссылка на чат: {LINKS['main']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;3&quot;: (&#10;            &quot; Канал (Премиум) — 1500₽\n&quot;&#10;            &quot;• Размещение навсегда.\n&quot;&#10;            &quot;• Без закрепа по умолчанию. Можно добавить: Закреп.\n&quot;&#10;            f&quot;• Ссылка на премиум-канал: {LINKS['premium']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;4&quot;: (&#10;            &quot; Пакет Стандарт — 1950₽ (вместо 3450₽)\n&quot;&#10;            &quot;• Основной чат (без закрепа).\n&quot;&#10;            &quot;• Премиум-канал (без закрепа).\n&quot;&#10;            &quot;• Закреп в бесплатном чате на 1 месяц.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;5&quot;: (&#10;            &quot; Пакет Стандарт + Закреп — 2450₽ (вместо 4550₽)\n&quot;&#10;            &quot;• Основной чат — с закрепом на 1 месяц.\n&quot;&#10;            &quot;• Премиум-канал — с закрепом на 1 месяц.\n&quot;&#10;            &quot;• Бесплатный чат — закреп на 1 месяц.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;6&quot;: (&#10;            &quot;⭐ Пакет Премиум\n&quot;&#10;            &quot;• Основной чат — закреп навсегда.\n&quot;&#10;            &quot;• Премиум-канал — закреп навсегда.\n&quot;&#10;            &quot;• Бесплатный чат — закреп навсегда.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        )&#10;    }&#10;}&#10;&#10;# Suboptions available&#10;SUBOPTIONS_AVAILABLE = {&#10;    &quot;employer&quot;: {&#10;        &quot;1&quot;: [&quot;pin&quot;],&#10;        &quot;2&quot;: [&quot;pin&quot;, &quot;boost&quot;],&#10;        &quot;3&quot;: [&quot;pin&quot;],&#10;        &quot;4&quot;: [],&#10;        &quot;5&quot;: [],&#10;        &quot;6&quot;: []&#10;    },&#10;    &quot;freelancer&quot;: {&#10;        &quot;1&quot;: [&quot;pin&quot;],&#10;        &quot;2&quot;: [&quot;pin&quot;, &quot;boost&quot;],&#10;        &quot;3&quot;: [&quot;pin&quot;],&#10;        &quot;4&quot;: [],&#10;        &quot;5&quot;: [],&#10;        &quot;6&quot;: []&#10;    }&#10;}&#10;&#10;# Prices dict for variants (новый прайс)&#10;PRICES_DICT = {&#10;    &quot;pin_free_chat&quot;: {&#10;        &quot;1_week&quot;: {&quot;text&quot;: &quot;1 неделя&quot;, &quot;price&quot;: 450},&#10;        &quot;2_weeks&quot;: {&quot;text&quot;: &quot;2 недели&quot;, &quot;price&quot;: 500},&#10;        &quot;3_weeks&quot;: {&quot;text&quot;: &quot;3 недели&quot;, &quot;price&quot;: 650},&#10;        &quot;1_month&quot;: {&quot;text&quot;: &quot;1 месяц&quot;, &quot;price&quot;: 750},&#10;        &quot;2_months&quot;: {&quot;text&quot;: &quot;2 месяца&quot;, &quot;price&quot;: 850},&#10;        &quot;3_months&quot;: {&quot;text&quot;: &quot;3 месяца&quot;, &quot;price&quot;: 1000},&#10;        &quot;6_months&quot;: {&quot;text&quot;: &quot;6 месяцев&quot;, &quot;price&quot;: 1750},&#10;        &quot;forever&quot;: {&quot;text&quot;: &quot;НАВСЕГДА&quot;, &quot;price&quot;: 2200},&#10;    },&#10;    &quot;pin_employer_chat&quot;: {&#10;        &quot;2_weeks&quot;: {&quot;text&quot;: &quot;2 недели&quot;, &quot;price&quot;: 400},&#10;        &quot;1_month&quot;: {&quot;text&quot;: &quot;1 месяц&quot;, &quot;price&quot;: 550},&#10;        &quot;3_months&quot;: {&quot;text&quot;: &quot;3 месяца&quot;, &quot;price&quot;: 1000},&#10;        &quot;forever&quot;: {&quot;text&quot;: &quot;НАВСЕГДА&quot;, &quot;price&quot;: 5000},&#10;    },&#10;    &quot;pin_freelancer_chat&quot;: {&#10;        &quot;1_month&quot;: {&quot;text&quot;: &quot;1 месяц&quot;, &quot;price&quot;: 550},&#10;        &quot;3_months&quot;: {&quot;text&quot;: &quot;3 месяца&quot;, &quot;price&quot;: 1000},&#10;        &quot;forever&quot;: {&quot;text&quot;: &quot;НАВСЕГДА&quot;, &quot;price&quot;: 5000},&#10;    },&#10;    &quot;pin_channel_employer&quot;: {&#10;        &quot;2_weeks&quot;: {&quot;text&quot;: &quot;2 недели&quot;, &quot;price&quot;: 550},&#10;        &quot;1_month&quot;: {&quot;text&quot;: &quot;1 месяц&quot;, &quot;price&quot;: 700},&#10;        &quot;3_months&quot;: {&quot;text&quot;: &quot;3 месяца&quot;, &quot;price&quot;: 1500},&#10;        &quot;forever&quot;: {&quot;text&quot;: &quot;НАВСЕГДА&quot;, &quot;price&quot;: 10000},&#10;    },&#10;    &quot;pin_channel_freelancer&quot;: {&#10;        &quot;2_weeks&quot;: {&quot;text&quot;: &quot;2 недели&quot;, &quot;price&quot;: 350},&#10;        &quot;1_month&quot;: {&quot;text&quot;: &quot;1 месяц&quot;, &quot;price&quot;: 550},&#10;        &quot;3_months&quot;: {&quot;text&quot;: &quot;3 месяца&quot;, &quot;price&quot;: 750},&#10;        &quot;forever&quot;: {&quot;text&quot;: &quot;НАВСЕГДА&quot;, &quot;price&quot;: 5000},&#10;    },&#10;    &quot;boost&quot;: {&#10;        &quot;1&quot;: {&quot;text&quot;: &quot;1 поднятие&quot;, &quot;price&quot;: 450},&#10;        &quot;2&quot;: {&quot;text&quot;: &quot;2 поднятия&quot;, &quot;price&quot;: 650},&#10;        &quot;3&quot;: {&quot;text&quot;: &quot;3 поднятия&quot;, &quot;price&quot;: 700},&#10;        &quot;4&quot;: {&quot;text&quot;: &quot;4 поднятия&quot;, &quot;price&quot;: 850},&#10;        &quot;5&quot;: {&quot;text&quot;: &quot;5 поднятий&quot;, &quot;price&quot;: 900},&#10;    },&#10;}&#10;&#10;SUBOPTION_EMOJIS = {&#10;    &quot;pin&quot;: &quot;&quot;,&#10;    &quot;boost&quot;: &quot;⬆️&quot;,&#10;}&#10;&#10;def get_suboption_key(suboption: str, user_type: str, option: str) -&gt; str:&#10;    if suboption == &quot;pin&quot;:&#10;        if option == &quot;1&quot;:&#10;            return &quot;pin_free_chat&quot;&#10;        elif option == &quot;2&quot;:&#10;            return &quot;pin_employer_chat&quot; if user_type == &quot;employer&quot; else &quot;pin_freelancer_chat&quot;&#10;        elif option == &quot;3&quot;:&#10;            return &quot;pin_channel_employer&quot; if user_type == &quot;employer&quot; else &quot;pin_channel_freelancer&quot;&#10;    elif suboption == &quot;boost&quot;:&#10;        return &quot;boost&quot;&#10;    return &quot;&quot;&#10;&#10;# Function to build extra text and keyboard (category buttons)&#10;async def build_extra_text_and_keyboard(state: FSMContext, user_type: str, option: str) -&gt; tuple[str, InlineKeyboardMarkup]:&#10;    data = await state.get_data()&#10;    selected = data.get(&quot;selected_suboptions&quot;, {})&#10;    available = SUBOPTIONS_AVAILABLE.get(user_type, {}).get(option, [])&#10;    base_price = BASE_PRICES[user_type][option]&#10;    desc = DESCRIPTIONS[user_type][option]&#10;    text = desc&#10;    builder = InlineKeyboardBuilder()&#10;    sub_total = 0&#10;    selected_text = &quot;&quot;&#10;&#10;    if available:&#10;        text += &quot;\n\nДополнительные опции:&quot;&#10;        for subopt in available:&#10;            sel_var = selected.get(subopt)&#10;            if sel_var:&#10;                key = get_suboption_key(subopt, user_type, option)&#10;                var_info = PRICES_DICT[key][sel_var]&#10;                price = var_info[&quot;price&quot;]&#10;                sub_total += price&#10;                selected_text += f&quot;\n- {SUBOPTION_EMOJIS[subopt]} {SUBOPTION_NAMES[subopt]} {var_info['text']} ({price}₽)&quot;&#10;            btext = f&quot;{SUBOPTION_EMOJIS[subopt]} {SUBOPTION_NAMES[subopt]}&quot;&#10;            if sel_var:&#10;                btext += f&quot; (выбрано: {PRICES_DICT[get_suboption_key(subopt, user_type, option)][sel_var]['text']})&quot;&#10;            builder.button(text=btext, callback_data=MenuCallback(level=&quot;subextra&quot;, user_type=user_type, option=option, suboption=subopt).pack())&#10;&#10;    total = base_price + sub_total&#10;    if selected_text:&#10;        text += &quot;\n\nВыбранные опции:&quot; + selected_text&#10;    text += f&quot;\n\nИтоговая цена: {total}₽&quot;&#10;&#10;    # Add Buy and Back&#10;    builder.button(text=&quot;Купить&quot;, callback_data=MenuCallback(level=&quot;buy&quot;, user_type=user_type, option=option).pack())&#10;    builder.button(text=&quot;Назад&quot;, callback_data=MenuCallback(level=&quot;sub&quot;, user_type=user_type).pack())&#10;    builder.adjust(2)  # Adjust to 2 per row for better layout&#10;    builder = add_contact_button(builder)&#10;    return text, builder.as_markup()&#10;&#10;# Function to build subextra text and keyboard (variants for a suboption)&#10;async def build_subextra_text_and_keyboard(state: FSMContext, user_type: str, option: str, suboption: str) -&gt; tuple[str, InlineKeyboardMarkup | None]:&#10;    data = await state.get_data()&#10;    selected = data.get(&quot;selected_suboptions&quot;, {})&#10;    key = get_suboption_key(suboption, user_type, option)&#10;    if not key:&#10;        return &quot;Ошибка&quot;, None&#10;    variants = PRICES_DICT[key]&#10;    sel_var = selected.get(suboption)&#10;    text = f&quot;{SUBOPTION_NAMES[suboption]}:&quot;&#10;    if suboption == 'boost':&#10;        text += &quot;\n\nПоднятие — это повторная публикация вашего поста с закрепом на 2 часа. Вы можете выбрать, сколько раз поднять пост.&quot;&#10;&#10;    builder = InlineKeyboardBuilder()&#10;    for var, info in variants.items():&#10;        if sel_var == var:&#10;            btext = f&quot;Удалить опцию {info['text']}&quot;&#10;            act = &quot;remove&quot;&#10;        else:&#10;            btext = f&quot;{info['text']} - {info['price']} рублей&quot;&#10;            act = &quot;add&quot;&#10;        builder.button(text=btext, callback_data=MenuCallback(level=&quot;toggle&quot;, user_type=user_type, option=option, suboption=suboption, variant=var, action=act).pack())&#10;    builder.button(text=&quot;Назад&quot;, callback_data=MenuCallback(level=&quot;extra&quot;, user_type=user_type, option=option).pack())&#10;    builder.adjust(2)&#10;    builder = add_contact_button(builder)&#10;    return text, builder.as_markup()&#10;&#10;# Handler for /start&#10;@menu_router.message(Command(&quot;start&quot;))&#10;async def command_start(message: Message):&#10;    text = (&#10;        &quot;Привет! Здесь можно быстро и удобно разместить вакансию или резюме\n\n&quot;&#10;        &quot;Чтобы начать, откройте главное меню командой /menu&quot;&#10;    )&#10;    kb = InlineKeyboardBuilder()&#10;    kb = add_contact_button(kb)&#10;    await message.answer(text, reply_markup=kb.as_markup())&#10;&#10;# Handler for /menu - shows initial menu with employer/freelancer choices&#10;@menu_router.message(Command(&quot;menu&quot;))&#10;async def command_menu(message: Message, state: FSMContext):&#10;    await state.clear()&#10;    # Приветственный текст с ссылками&#10;    intro = (&#10;        &quot;Добро пожаловать! Ниже — быстрые ссылки на наши площадки:\n&quot;&#10;        f&quot;• Основной чат: {LINKS['main']}\n&quot;&#10;        f&quot;• Премиум-канал: {LINKS['premium']}\n&quot;&#10;        f&quot;• Бесплатный чат: {LINKS['free']}\n&quot;&#10;        f&quot;• Чат с отзывами: {LINKS['reviews']}\n\n&quot;&#10;        &quot;Выберите категорию.\n&quot;&#10;        &quot;Важно: указывайте верный статус (Фрилансер/Работодатель) — объявления проходят модерацию и при неверном выборе могут быть отклонены.&quot;&#10;    )&#10;    builder = InlineKeyboardBuilder()&#10;    builder.button(text=&quot;А) Для работодателей&quot;, callback_data=MenuCallback(level=&quot;sub&quot;, user_type=&quot;employer&quot;).pack())&#10;    builder.button(text=&quot;Б) Для фрилансеров&quot;, callback_data=MenuCallback(level=&quot;sub&quot;, user_type=&quot;freelancer&quot;).pack())&#10;    builder.adjust(1)  # One button per row&#10;    builder = add_contact_button(builder)&#10;    await message.answer(intro, reply_markup=builder.as_markup())&#10;&#10;# Main callback query handler&#10;@menu_router.callback_query(MenuCallback.filter())&#10;async def process_menu_callback(query: CallbackQuery, callback_data: MenuCallback, state: FSMContext, bot: Bot):&#10;    rus_names = {'freelancer': 'Фрилансера', 'employer': 'Работодателя'}&#10;    level = callback_data.level&#10;    user_type = callback_data.user_type&#10;    option = callback_data.option&#10;    suboption = callback_data.suboption&#10;    variant = callback_data.variant&#10;    action = callback_data.action&#10;&#10;    await query.answer()  # Acknowledge the callback&#10;&#10;    if level == &quot;sub&quot;:&#10;        await state.clear()&#10;        builder = InlineKeyboardBuilder()&#10;        options = [&#10;            (&quot;Бесплатный чат (только закреп)&quot;, &quot;1&quot;),&#10;            (&quot;Платный чат&quot;, &quot;2&quot;),&#10;            (&quot;Канал&quot;, &quot;3&quot;),&#10;            (&quot;Пакет Стандарт&quot;, &quot;4&quot;),&#10;            (&quot;Пакет Стандарт+Закреп&quot;, &quot;5&quot;),&#10;            (&quot;Пакет Премиум&quot;, &quot;6&quot;)&#10;        ]&#10;        for text, opt in options:&#10;            if opt in BASE_PRICES.get(user_type, {}):&#10;                builder.button(text=f&quot;{OPTION_EMOJIS[opt]} {text}&quot;, callback_data=MenuCallback(level=&quot;extra&quot;, user_type=user_type, option=opt).pack())&#10;        builder.button(text=&quot;Назад&quot;, callback_data=MenuCallback(level=&quot;main&quot;).pack())&#10;        builder.adjust(2)&#10;        builder = add_contact_button(builder)&#10;        header = (&#10;            f&quot;Меню для {rus_names[user_type]}:\n\n&quot;&#10;            &quot;— Выберите площадку или пакет размещения ниже.\n&quot;&#10;            &quot;— Важно: указывайте верный статус (Фрилансер/Работодатель) — объявление проходит модерацию и при неверном выборе может быть отклонено.&quot;&#10;        )&#10;        await query.message.edit_text(header, reply_markup=builder.as_markup())&#10;&#10;    elif level == &quot;extra&quot;:&#10;        data = await state.get_data()&#10;        current_option = data.get('option')&#10;        if current_option != option:&#10;            selected = {}&#10;        else:&#10;            selected = data.get('selected_suboptions', {})&#10;        await state.update_data(user_type=user_type, option=option, selected_suboptions=selected)&#10;        text, markup = await build_extra_text_and_keyboard(state, user_type, option)&#10;        await query.message.edit_text(text, reply_markup=markup)&#10;&#10;    elif level == &quot;subextra&quot;:&#10;        text, markup = await build_subextra_text_and_keyboard(state, user_type, option, suboption)&#10;        await query.message.edit_text(text, reply_markup=markup)&#10;&#10;    elif level == &quot;toggle&quot;:&#10;        data = await state.get_data()&#10;        selected = data.get(&quot;selected_suboptions&quot;, {})&#10;        subopt_name = SUBOPTION_NAMES.get(suboption, suboption)&#10;        key = get_suboption_key(suboption, user_type, option)&#10;        var_info = PRICES_DICT[key].get(variant, {})&#10;        var_text = var_info.get(&quot;text&quot;, variant)&#10;        if action == &quot;add&quot;:&#10;            selected[suboption] = variant&#10;            await query.answer(f&quot;К заказу добавлена опция {subopt_name} {var_text}&quot;)&#10;        elif action == &quot;remove&quot;:&#10;            if suboption in selected:&#10;                del selected[suboption]&#10;            await query.answer(f&quot;Опция {subopt_name} удалена из заказа&quot;)&#10;        await state.update_data(selected_suboptions=selected)&#10;        # Return to subextra view after toggle&#10;        text, markup = await build_subextra_text_and_keyboard(state, user_type, option, suboption)&#10;        await query.message.edit_text(text, reply_markup=markup)&#10;&#10;    elif level == &quot;buy&quot;:&#10;        data = await state.get_data()&#10;        selected = data.get(&quot;selected_suboptions&quot;, {})&#10;        base_price = BASE_PRICES[user_type][option]&#10;        sub_total = 0&#10;        for subopt, var in selected.items():&#10;            key = get_suboption_key(subopt, user_type, option)&#10;            sub_total += PRICES_DICT[key][var][&quot;price&quot;]&#10;        total = base_price + sub_total&#10;        await state.update_data(total=total, selected_suboptions=selected)&#10;        await state.set_state(Purchase.waiting_check)&#10;        # Remove buttons from previous message&#10;        await bot.edit_message_reply_markup(chat_id=query.from_user.id, message_id=query.message.message_id, reply_markup=None)&#10;        # Send new message with cancel (без кнопки контакта на этапе оплаты)&#10;        cancel_builder = InlineKeyboardBuilder()&#10;        cancel_builder.button(text=&quot;Отмена&quot;, callback_data=MenuCallback(level=&quot;cancel&quot;).pack())&#10;        final_price_text = (f&quot;Итоговая цена: {total}₽.\nОтправьте фотографию чека оплаты на сумму {total}₽.\n\n&quot;&#10;                            f&quot;Реквизиты для оплаты:\n&quot;&#10;                            f&quot;Сбербанк:\n&quot;&#10;                            f&quot;Даниил Дмитриевич М.\n&quot;&#10;                            f&quot;2202206250331753\n&quot;&#10;                            f&quot;Можно по номеру:\n&quot;&#10;                            f&quot;89164253032&quot;)&#10;        sent_msg = await bot.send_message(query.from_user.id, text=final_price_text, reply_markup=cancel_builder.as_markup())&#10;        await state.update_data(waiting_msg_id=sent_msg.message_id)&#10;&#10;    elif level == &quot;main&quot;:&#10;        await state.clear()&#10;        builder = InlineKeyboardBuilder()&#10;        builder.button(text=&quot;А) Для работодателей&quot;, callback_data=MenuCallback(level=&quot;sub&quot;, user_type=&quot;employer&quot;).pack())&#10;        builder.button(text=&quot;Б) Для фрилансеров&quot;, callback_data=MenuCallback(level=&quot;sub&quot;, user_type=&quot;freelancer&quot;).pack())&#10;        builder.adjust(1)&#10;        builder = add_contact_button(builder)&#10;        await query.message.edit_text(&quot;Выберите категорию:&quot;, reply_markup=builder.as_markup())&#10;&#10;    elif level == &quot;cancel&quot;:&#10;        data = await state.get_data()&#10;        waiting_msg_id = data.get(&quot;waiting_msg_id&quot;)&#10;        if waiting_msg_id:&#10;            await bot.edit_message_text(chat_id=query.from_user.id, message_id=waiting_msg_id, text=&quot;Покупка отменена.&quot;, reply_markup=None)&#10;        await state.clear()&#10;&#10;# Handler for payment check photo&#10;@menu_router.message(Purchase.waiting_check, F.photo)&#10;async def process_check_photo(message: Message, state: FSMContext, bot: Bot):&#10;    photo_id = message.photo[-1].file_id  # Get the highest resolution photo&#10;    await state.update_data(check_photo=photo_id)&#10;    data = await state.get_data()&#10;    waiting_msg_id = data.get('waiting_msg_id')&#10;    if waiting_msg_id:&#10;        # остаёмся без кнопок на этапе оплаты&#10;        await bot.edit_message_text(chat_id=message.chat.id, message_id=waiting_msg_id, text=&quot;Чек получен.&quot;, reply_markup=None)&#10;&#10;    user_type = data.get('user_type')&#10;    hashtag = '#ищу' if user_type == 'employer' else '#помогу'&#10;&#10;    # Следующий шаг (отправка поста) — показываем кнопку контакта и правила по хэштегам&#10;    kb = InlineKeyboardBuilder()&#10;    kb = add_contact_button(kb)&#10;    post_rules_text = (&#10;        &quot;Теперь отправьте пост, который хотите опубликовать.\n\n&quot;&#10;        &quot;&lt;b&gt;Важно:&lt;/b&gt;\n&quot;&#10;        f&quot;• Ваш пост должен содержать обязательный хэштег: &lt;code&gt;{hashtag}&lt;/code&gt;\n&quot;&#10;        &quot;• Убедитесь, что хэштег написан правильно и присутствует в тексте вашего объявления.&quot;&#10;    )&#10;    await bot.send_message(message.chat.id, post_rules_text, reply_markup=kb.as_markup(), parse_mode=ParseMode.HTML)&#10;    await state.set_state(Purchase.waiting_post)&#10;&#10;# Handler for post content&#10;@menu_router.message(Purchase.waiting_post)&#10;async def process_post_content(message: Message, state: FSMContext, bot: Bot, album: List[Message] | None = None):&#10;    data = await state.get_data()&#10;    user_type = data.get('user_type')&#10;    required_hashtag = '#ищу' if user_type == 'employer' else '#помогу'&#10;&#10;    if album:&#10;        # Обработка медиа-группы (альбома)&#10;        content_type = 'photo'&#10;        file_ids = [msg.photo[-1].file_id for msg in album if msg.photo]&#10;        text = next((msg.caption for msg in album if msg.caption), '')  # Caption от первого с текстом&#10;        media_group_id = 0  # используем 0, чтобы не сохранять строковый идентификатор&#10;    else:&#10;        # Одиночное сообщение&#10;        media_group_id = message.media_group_id&#10;        if message.text:&#10;            content_type = 'text'&#10;            text = message.text&#10;            file_ids = []&#10;        elif message.photo:&#10;            content_type = 'photo'&#10;            text = message.caption or ''&#10;            file_ids = [message.photo[-1].file_id]&#10;        else:&#10;            kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;            await message.answer(&quot;Пожалуйста, отправьте текст или фото.&quot;, reply_markup=kb.as_markup())&#10;            return&#10;&#10;    # Проверка хэштега&#10;    if required_hashtag not in text:&#10;        kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;        await message.reply(&#10;            f&quot;Ошибка: в вашем посте отсутствует обязательный хэштег &lt;code&gt;{required_hashtag}&lt;/code&gt;. &quot;&#10;            f&quot;Пожалуйста, исправьте и отправьте пост заново.&quot;,&#10;            reply_markup=kb.as_markup(),&#10;            parse_mode=ParseMode.HTML&#10;        )&#10;        return&#10;&#10;    await state.update_data(content_type=content_type, text=text, file_ids=file_ids, media_group_id=media_group_id)&#10;&#10;    # Generate unique order ID&#10;    order_id = str(uuid.uuid4())&#10;&#10;    # Store order data&#10;    pending_orders[order_id] = {&#10;        'user_id': message.from_user.id,&#10;        'user_username': message.from_user.username,&#10;        'user_type': data['user_type'],&#10;        'option': data['option'],&#10;        'selected_suboptions': data['selected_suboptions'],&#10;        'total': data['total'],&#10;        'check_photo': data['check_photo'],&#10;        'content_type': content_type,&#10;        'text': text,&#10;        'file_ids': file_ids,&#10;        'media_group_id': media_group_id&#10;    }&#10;&#10;    # Format suboptions string&#10;    suboptions_str = ', '.join([f&quot;{SUBOPTION_NAMES.get(k, k)}: {PRICES_DICT[get_suboption_key(k, data['user_type'], data['option'])][v]['text']}&quot; for k, v in data['selected_suboptions'].items()]) if data['selected_suboptions'] else 'Нет'&#10;&#10;    # If post has photos, send them to admin first&#10;    if file_ids:&#10;        media = [InputMediaPhoto(media=file_id, caption=text if i == 0 else None, parse_mode=ParseMode.HTML) for i, file_id in enumerate(file_ids)]&#10;        await bot.send_media_group(ADMIN_CHAT_ID, media)&#10;        post_str = &quot;Пост: опубликован выше&quot;&#10;    else:&#10;        await bot.send_message(ADMIN_CHAT_ID, text)&#10;        post_str = f&quot;Пост: опубликован выше&quot;&#10;&#10;    # Build admin keyboard&#10;    builder = InlineKeyboardBuilder()&#10;    builder.button(text=&quot;Подтвердить&quot;, callback_data=AdminCallback(action=&quot;confirm&quot;, order_id=order_id).pack())&#10;    builder.button(text=&quot;Отклонить&quot;, callback_data=AdminCallback(action=&quot;reject&quot;, order_id=order_id).pack())&#10;    builder.adjust(2)&#10;&#10;    # Send check photo with caption and buttons to admin&#10;    caption = (&#10;        f&quot;Новый заказ #{order_id[:8]}\n&quot;&#10;        f&quot;От пользователя: @{message.from_user.username} (ID: {message.from_user.id})\n&quot;&#10;        f&quot;Тип: {data['user_type'].capitalize()}\n&quot;&#10;        f&quot;Опция: {DESCRIPTIONS[data['user_type']][data['option']].splitlines()[0]}\n&quot;&#10;        f&quot;Дополнительные опции: {suboptions_str}\n&quot;&#10;        f&quot;Сумма: {data['total']}₽\n&quot;&#10;        f&quot;{post_str}&quot;&#10;    )&#10;    await bot.send_photo(ADMIN_CHAT_ID, photo=data['check_photo'], caption=caption, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)&#10;&#10;    # Пользователю — ответ с кнопкой контакта&#10;    kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;    await message.answer(&quot;Пост получен и отправлен на модерацию. Спасибо!&quot;, reply_markup=kb.as_markup())&#10;    await state.clear()&#10;&#10;# Admin callback handler&#10;@menu_router.callback_query(AdminCallback.filter())&#10;async def process_admin_callback(query: CallbackQuery, callback_data: AdminCallback, state: FSMContext, bot: Bot):&#10;    from datetime import datetime, timedelta&#10;    import os&#10;    import pytz&#10;    from app.database import requests as req&#10;&#10;    order_id = callback_data.order_id&#10;    action = callback_data.action&#10;&#10;    if action == 'reject':&#10;        await state.update_data(order_id_to_reject=order_id)&#10;        await query.message.answer(&quot;Введите причину отклонения заказа:&quot;)&#10;        await state.set_state(AdminReject.waiting_reason)&#10;        await query.answer()&#10;        return&#10;&#10;    def parse_pin_variant_to_delta(var: str) -&gt; timedelta | None:&#10;        mapping = {&#10;            '1_week': timedelta(weeks=1),&#10;            '2_weeks': timedelta(weeks=2),&#10;            '3_weeks': timedelta(weeks=3),&#10;            '1_month': timedelta(days=30),&#10;            '2_months': timedelta(days=60),&#10;            '3_months': timedelta(days=90),&#10;            '6_months': timedelta(days=180),&#10;            'forever': None,&#10;        }&#10;        return mapping.get(var)&#10;&#10;    def forever_dt(tz) -&gt; datetime:&#10;        return tz.localize(datetime.strptime(&quot;12:00 31-12-2200&quot;, &quot;%H:%M %d-%m-%Y&quot;))&#10;&#10;    def compute_targets(user_type: str, option: str) -&gt; List[int | str] | List[List[int | str]]:&#10;        # Для пакетов возвращаем список чатов, для обычных — один&#10;        free_chat = int(os.getenv('FREE_CHAT_ID', '0'))&#10;        main_chat = int(os.getenv('MAIN_CHAT_ID', '0'))&#10;        channel = int(os.getenv('CHANNEL_ID', '0'))  # теперь это премиум-канал&#10;        if option == '1':&#10;            return [free_chat]&#10;        if option == '2':&#10;            return [main_chat]&#10;        if option == '3':&#10;            return [channel]&#10;        if option in ('4', '5', '6'):&#10;            return [main_chat, channel, free_chat]&#10;        return [channel]&#10;&#10;    def get_boost_count(selected: dict) -&gt; int:&#10;        try:&#10;            var = selected.get('boost')&#10;            return int(var) if var and var.isdigit() else 0&#10;        except Exception:&#10;            return 0&#10;&#10;    await query.answer()&#10;&#10;    if order_id in pending_orders:&#10;        order = pending_orders.pop(order_id)&#10;        user_id = order['user_id']&#10;&#10;        if action == &quot;confirm&quot;:&#10;            # Сохраняем пост(ы) в БД как ScheduledPost по целевым чатам&#10;            tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;            now = datetime.now(tz)&#10;            scheduled_time = now + timedelta(seconds=90)&#10;            selected = order.get('selected_suboptions', {})&#10;            user_type = order['user_type']&#10;            option = order['option']&#10;            pin_variant = selected.get('pin')&#10;            pin_delta = parse_pin_variant_to_delta(pin_variant) if pin_variant else None&#10;            boost_count = get_boost_count(selected)&#10;&#10;            # Время удаления: все размещения теперь навсегда&#10;            delete_time_base = forever_dt(tz)&#10;&#10;            targets = compute_targets(user_type, option)&#10;            for chat_id in targets:&#10;                # unpin_time по правилам для основной публикации:&#10;                if option == '4':&#10;                    # Пакет 4: закреп только в бесплатном чате на 1 месяц&#10;                    if chat_id == int(os.getenv('FREE_CHAT_ID', '0')):&#10;                        unpin_time = now + timedelta(days=30)&#10;                    else:&#10;                        unpin_time = None&#10;                elif option == '5':&#10;                    # Пакет 5: закреп 1 месяц во всех входящих чатиках&#10;                    unpin_time = now + timedelta(days=30)&#10;                elif option == '6':&#10;                    # Пакет 6: закреп навсегда&#10;                    unpin_time = forever_dt(tz)&#10;                else:&#10;                    # Обычные: если выбрана опция pin — берём её, forever -&gt; 2200; иначе без закрепа&#10;                    if pin_delta is not None:&#10;                        unpin_time = now + pin_delta&#10;                    elif pin_variant == 'forever':&#10;                        unpin_time = forever_dt(tz)&#10;                    else:&#10;                        unpin_time = None&#10;&#10;                # delete_time по правилам&#10;                delete_time = delete_time_base&#10;&#10;                # Основная публикация&#10;                await req.add_or_update_scheduled_post(&#10;                    content_type=order['content_type'],&#10;                    text=order['text'],&#10;                    photo_file_ids=order['file_ids'],&#10;                    scheduled_time=scheduled_time.replace(tzinfo=None),  # в БД без tz&#10;                    media_group_id=order['media_group_id'] or 0,&#10;                    unpin_time=unpin_time.replace(tzinfo=None) if unpin_time else None,&#10;                    delete_time=delete_time.replace(tzinfo=None) if delete_time else None,&#10;                    chat_id=int(chat_id)&#10;                )&#10;&#10;                # Поднятия: дублируем пост boost_count раз, каждые +2 часа, с закрепом на 2 часа&#10;                for i in range(1, boost_count + 1):&#10;                    st = (now + timedelta(hours=2 * i)).replace(tzinfo=None)&#10;                    unpin_boost = (now + timedelta(hours=2 * i + 2)).replace(tzinfo=None)&#10;                    await req.add_or_update_scheduled_post(&#10;                        content_type=order['content_type'],&#10;                        text=order['text'],&#10;                        photo_file_ids=order['file_ids'],&#10;                        scheduled_time=st,&#10;                        media_group_id=order['media_group_id'] or 0,&#10;                        unpin_time=unpin_boost,&#10;                        delete_time=delete_time.replace(tzinfo=None) if delete_time else None,&#10;                        chat_id=int(chat_id)&#10;                    )&#10;&#10;            # Уведомление пользователю с кнопкой контакта&#10;            kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;            await bot.send_message(user_id, &quot;Ваш заказ подтверждён! Посты запланированы к публикации.&quot;, reply_markup=kb.as_markup())&#10;            status = &quot;Подтверждено&quot;&#10;&#10;        await query.message.edit_caption(caption=query.message.caption + f&quot;\n\nСтатус: {status}&quot;, reply_markup=None)&#10;    else:&#10;        await query.answer(&quot;Заказ не найден или уже обработан.&quot;)&#10;&#10;# Новый обработчик для получения причины отклонения от админа&#10;@menu_router.message(AdminReject.waiting_reason)&#10;async def process_rejection_reason(message: Message, state: FSMContext, bot: Bot):&#10;    reason = message.text&#10;    data = await state.get_data()&#10;    order_id = data.get('order_id_to_reject')&#10;&#10;    if order_id in pending_orders:&#10;        order = pending_orders.pop(order_id)&#10;        user_id = order['user_id']&#10;&#10;        # Отправляем пользователю сообщение с причиной&#10;        kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;        await bot.send_message(&#10;            user_id,&#10;            f&quot;Ваш заказ был отклонён.\n\n&lt;b&gt;Причина:&lt;/b&gt; {reason}&quot;,&#10;            reply_markup=kb.as_markup(),&#10;            parse_mode=ParseMode.HTML&#10;        )&#10;&#10;        # Обновляем сообщение в админском чате&#10;        # (Предполагается, что админ отвечает на сообщение с заказом, но это сложно отследить без reply)&#10;        # Проще просто уведомить админа, что причина отправлена&#10;        await message.answer(f&quot;Причина отклонения для заказа #{order_id[:8]} отправлена пользователю.&quot;)&#10;&#10;    await state.clear()&#10;&#10;&#10;# Fallback for wrong input in states&#10;@menu_router.message(Purchase.waiting_check)&#10;async def invalid_check(message: Message):&#10;    kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;    await message.answer(&quot;Пожалуйста, отправьте фотографию чека.&quot;, reply_markup=kb.as_markup())&#10;&#10;@menu_router.message(Purchase.waiting_post)&#10;async def invalid_post(message: Message):&#10;    kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;    await message.answer(&quot;Пожалуйста, отправьте текст или фото.&quot;, reply_markup=kb.as_markup())&#10;" />
              <option name="updatedContent" value="import os&#10;from typing import Dict, List&#10;import uuid&#10;import dotenv&#10;from aiogram import Bot, F, Router&#10;from aiogram.enums import ParseMode&#10;from aiogram.filters import Command&#10;from aiogram.filters.callback_data import CallbackData&#10;from aiogram.fsm.context import FSMContext&#10;from aiogram.fsm.state import State, StatesGroup&#10;from aiogram.types import CallbackQuery, InlineKeyboardMarkup, InputMediaPhoto, Message, InlineKeyboardButton&#10;from aiogram.utils.keyboard import InlineKeyboardBuilder&#10;&#10;&#10;dotenv.load_dotenv()&#10;# Загружаем ID чатов из окружения&#10;ADMIN_CHAT_ID = int(os.getenv('ADMIN_CHAT_ID', '0'))&#10;NOTIFICATION_CHAT = int(os.getenv('NOTIFICATION_CHAT', str(ADMIN_CHAT_ID)))&#10;&#10;# Быстрые ссылки на наши площадки&#10;LINKS = {&#10;    'main': 'https://t.me/FreelanceSET',&#10;    'premium': 'https://t.me/VakansiiPREMIUM',&#10;    'free': 'https://t.me/freelanceFREEchat',&#10;    'reviews': 'https://t.me/PUSHfeedback',&#10;}&#10;&#10;ADMIN_CONTACT_URL = 'https://t.me/push_admin_Evgen'&#10;&#10;# Утилита: добавить кнопку «Связаться с админом» в самый низ клавиатуры&#10;def add_contact_button(builder: InlineKeyboardBuilder) -&gt; InlineKeyboardBuilder:&#10;    builder.row(InlineKeyboardButton(text='Связаться с админом', url=ADMIN_CONTACT_URL))&#10;    return builder&#10;&#10;# Global storage for pending orders&#10;pending_orders: Dict[str, Dict] = {}&#10;&#10;# Define FSM states for the purchase process&#10;class Purchase(StatesGroup):&#10;    waiting_check = State()  # Waiting for payment check photo&#10;    waiting_post = State()   # Waiting for the post text&#10;&#10;# Новый FSM для админа при отклонении&#10;class AdminReject(StatesGroup):&#10;    waiting_reason = State()&#10;&#10;# Define CallbackData factory for menu navigation&#10;class MenuCallback(CallbackData, prefix=&quot;menu&quot;):&#10;    level: str  # e.g., 'main', 'sub', 'extra', 'subextra', 'toggle', 'buy', 'cancel'&#10;    user_type: str = &quot;&quot;  # 'employer' or 'freelancer'&#10;    option: str = &quot;&quot;     # '1', '2', etc.&#10;    suboption: str = &quot;&quot;  # For extra options like 'pin', 'boost'&#10;    variant: str = &quot;&quot;    # For variants like '1_month', 'forever'&#10;    action: str = &quot;&quot;     # 'add' or 'remove' for toggle&#10;&#10;# Define CallbackData for admin actions&#10;class AdminCallback(CallbackData, prefix=&quot;admin&quot;):&#10;    action: str  # 'confirm' or 'reject'&#10;    order_id: str&#10;&#10;menu_router = Router()&#10;&#10;# Suboption names&#10;SUBOPTION_NAMES = {&#10;    &quot;pin&quot;: &quot;Закреп&quot;,&#10;    &quot;boost&quot;: &quot;Поднятие&quot;,&#10;}&#10;&#10;# Emoji for main options&#10;OPTION_EMOJIS = {&#10;    &quot;1&quot;: &quot;&quot;,&#10;    &quot;2&quot;: &quot;&quot;,&#10;    &quot;3&quot;: &quot;&quot;,&#10;    &quot;4&quot;: &quot;&quot;,&#10;    &quot;5&quot;: &quot;&quot;,&#10;    &quot;6&quot;: &quot;⭐&quot;&#10;}&#10;&#10;# Base prices (новый прайс)&#10;BASE_PRICES = {&#10;    &quot;employer&quot;: {&#10;        &quot;1&quot;: 0,          # Бесплатный чат — только закреп (без размещения)&#10;        &quot;2&quot;: 1600,       # Платный чат&#10;        &quot;3&quot;: 2400,       # Канал (премиум)&#10;        &quot;4&quot;: 2700,       # Пакет Стандарт&#10;        &quot;5&quot;: 3200,       # Пакет Стандарт + Закреп&#10;        &quot;6&quot;: 10000       # Пакет Премиум (оставлен как ранее)&#10;    },&#10;    &quot;freelancer&quot;: {&#10;        &quot;1&quot;: 0,          # Бесплатный чат — только закреп (без размещения)&#10;        &quot;2&quot;: 1200,       # Платный чат&#10;        &quot;3&quot;: 1500,       # Канал (премиум)&#10;        &quot;4&quot;: 1950,       # Пакет Стандарт&#10;        &quot;5&quot;: 2450,       # Пакет Стандарт + Закреп&#10;        &quot;6&quot;: 5000        # Пакет Премиум (оставлен как ранее)&#10;    }&#10;}&#10;&#10;# Descriptions с расширенным пояснением и ссылками&#10;DESCRIPTIONS = {&#10;    &quot;employer&quot;: {&#10;        &quot;1&quot;: (&#10;            &quot; Бесплатный чат — только закреп\n&quot;&#10;            &quot;• Публикация бесплатная, покупается только закреп в бесплатном чате.\n&quot;&#10;            &quot;• Закреп удерживает ваш пост вверху чата выбранный срок.\n&quot;&#10;            f&quot;• Ссылка на чат: {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;2&quot;: (&#10;            &quot; Стандарт (Платный чат) — 1600₽\n&quot;&#10;            &quot;• Размещение навсегда.\n&quot;&#10;            &quot;• Без закрепа по умолчанию. Можно добавить: Закреп.\n&quot;&#10;            f&quot;• Ссылка на чат: {LINKS['main']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;3&quot;: (&#10;            &quot; Канал (Премиум) — 2400₽\n&quot;&#10;            &quot;• Размещение навсегда.\n&quot;&#10;            &quot;• Без закрепа по умолчанию. Можно добавить: Закреп.\n&quot;&#10;            f&quot;• Ссылка на премиум-канал: {LINKS['premium']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;4&quot;: (&#10;            &quot; Пакет Стандарт — 2700₽ (вместо 4750₽)\n&quot;&#10;            &quot;• Основной чат (без закрепа).\n&quot;&#10;            &quot;• Премиум-канал (без закрепа).\n&quot;&#10;            &quot;• Закреп в бесплатном чате на 1 месяц.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;5&quot;: (&#10;            &quot; Пакет Стандарт + Закреп — 3200₽ (вместо 6000₽)\n&quot;&#10;            &quot;• Основной чат — с закрепом на 1 месяц.\n&quot;&#10;            &quot;• Премиум-канал — с закрепом на 1 месяц.\n&quot;&#10;            &quot;• Бесплатный чат — закреп на 1 месяц.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;6&quot;: (&#10;            &quot;⭐ Пакет Премиум\n&quot;&#10;            &quot;• Основной чат — закреп навсегда.\n&quot;&#10;            &quot;• Премиум-канал — закреп навсегда.\n&quot;&#10;            &quot;• Бесплатный чат — закреп навсегда.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        )&#10;    },&#10;    &quot;freelancer&quot;: {&#10;        &quot;1&quot;: (&#10;            &quot; Бесплатный чат — только закреп\n&quot;&#10;            &quot;• Публикация бесплатная, покупается только закреп в бесплатном чате.\n&quot;&#10;            &quot;• Закреп удерживает ваш пост вверху чата выбранный срок.\n&quot;&#10;            f&quot;• Ссылка на чат: {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;2&quot;: (&#10;            &quot; Стандарт (Платный чат) — 1200₽\n&quot;&#10;            &quot;• Размещение навсегда.\n&quot;&#10;            &quot;• Без закрепа по умолчанию. Можно добавить: Закреп.\n&quot;&#10;            f&quot;• Ссылка на чат: {LINKS['main']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;3&quot;: (&#10;            &quot; Канал (Премиум) — 1500₽\n&quot;&#10;            &quot;• Размещение навсегда.\n&quot;&#10;            &quot;• Без закрепа по умолчанию. Можно добавить: Закреп.\n&quot;&#10;            f&quot;• Ссылка на премиум-канал: {LINKS['premium']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;4&quot;: (&#10;            &quot; Пакет Стандарт — 1950₽ (вместо 3450₽)\n&quot;&#10;            &quot;• Основной чат (без закрепа).\n&quot;&#10;            &quot;• Премиум-канал (без закрепа).\n&quot;&#10;            &quot;• Закреп в бесплатном чате на 1 месяц.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;5&quot;: (&#10;            &quot; Пакет Стандарт + Закреп — 2450₽ (вместо 4550₽)\n&quot;&#10;            &quot;• Основной чат — с закрепом на 1 месяц.\n&quot;&#10;            &quot;• Премиум-канал — с закрепом на 1 месяц.\n&quot;&#10;            &quot;• Бесплатный чат — закреп на 1 месяц.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        ),&#10;        &quot;6&quot;: (&#10;            &quot;⭐ Пакет Премиум\n&quot;&#10;            &quot;• Основной чат — закреп навсегда.\n&quot;&#10;            &quot;• Премиум-канал — закреп навсегда.\n&quot;&#10;            &quot;• Бесплатный чат — закреп навсегда.\n&quot;&#10;            f&quot;• Ссылки: \nосновной {LINKS['main']}\nпремиум {LINKS['premium']}\nбесплатный {LINKS['free']}\n&quot;&#10;            f&quot;• Чат с отзывами: {LINKS['reviews']}&quot;&#10;        )&#10;    }&#10;}&#10;&#10;# Suboptions available&#10;SUBOPTIONS_AVAILABLE = {&#10;    &quot;employer&quot;: {&#10;        &quot;1&quot;: [&quot;pin&quot;],&#10;        &quot;2&quot;: [&quot;pin&quot;, &quot;boost&quot;],&#10;        &quot;3&quot;: [&quot;pin&quot;],&#10;        &quot;4&quot;: [],&#10;        &quot;5&quot;: [],&#10;        &quot;6&quot;: []&#10;    },&#10;    &quot;freelancer&quot;: {&#10;        &quot;1&quot;: [&quot;pin&quot;],&#10;        &quot;2&quot;: [&quot;pin&quot;, &quot;boost&quot;],&#10;        &quot;3&quot;: [&quot;pin&quot;],&#10;        &quot;4&quot;: [],&#10;        &quot;5&quot;: [],&#10;        &quot;6&quot;: []&#10;    }&#10;}&#10;&#10;# Prices dict for variants (новый прайс)&#10;PRICES_DICT = {&#10;    &quot;pin_free_chat&quot;: {&#10;        &quot;1_week&quot;: {&quot;text&quot;: &quot;1 неделя&quot;, &quot;price&quot;: 450},&#10;        &quot;2_weeks&quot;: {&quot;text&quot;: &quot;2 недели&quot;, &quot;price&quot;: 500},&#10;        &quot;3_weeks&quot;: {&quot;text&quot;: &quot;3 недели&quot;, &quot;price&quot;: 650},&#10;        &quot;1_month&quot;: {&quot;text&quot;: &quot;1 месяц&quot;, &quot;price&quot;: 750},&#10;        &quot;2_months&quot;: {&quot;text&quot;: &quot;2 месяца&quot;, &quot;price&quot;: 850},&#10;        &quot;3_months&quot;: {&quot;text&quot;: &quot;3 месяца&quot;, &quot;price&quot;: 1000},&#10;        &quot;6_months&quot;: {&quot;text&quot;: &quot;6 месяцев&quot;, &quot;price&quot;: 1750},&#10;        &quot;forever&quot;: {&quot;text&quot;: &quot;НАВСЕГДА&quot;, &quot;price&quot;: 2200},&#10;    },&#10;    &quot;pin_employer_chat&quot;: {&#10;        &quot;2_weeks&quot;: {&quot;text&quot;: &quot;2 недели&quot;, &quot;price&quot;: 400},&#10;        &quot;1_month&quot;: {&quot;text&quot;: &quot;1 месяц&quot;, &quot;price&quot;: 550},&#10;        &quot;3_months&quot;: {&quot;text&quot;: &quot;3 месяца&quot;, &quot;price&quot;: 1000},&#10;        &quot;forever&quot;: {&quot;text&quot;: &quot;НАВСЕГДА&quot;, &quot;price&quot;: 5000},&#10;    },&#10;    &quot;pin_freelancer_chat&quot;: {&#10;        &quot;1_month&quot;: {&quot;text&quot;: &quot;1 месяц&quot;, &quot;price&quot;: 550},&#10;        &quot;3_months&quot;: {&quot;text&quot;: &quot;3 месяца&quot;, &quot;price&quot;: 1000},&#10;        &quot;forever&quot;: {&quot;text&quot;: &quot;НАВСЕГДА&quot;, &quot;price&quot;: 5000},&#10;    },&#10;    &quot;pin_channel_employer&quot;: {&#10;        &quot;2_weeks&quot;: {&quot;text&quot;: &quot;2 недели&quot;, &quot;price&quot;: 550},&#10;        &quot;1_month&quot;: {&quot;text&quot;: &quot;1 месяц&quot;, &quot;price&quot;: 700},&#10;        &quot;3_months&quot;: {&quot;text&quot;: &quot;3 месяца&quot;, &quot;price&quot;: 1500},&#10;        &quot;forever&quot;: {&quot;text&quot;: &quot;НАВСЕГДА&quot;, &quot;price&quot;: 10000},&#10;    },&#10;    &quot;pin_channel_freelancer&quot;: {&#10;        &quot;2_weeks&quot;: {&quot;text&quot;: &quot;2 недели&quot;, &quot;price&quot;: 350},&#10;        &quot;1_month&quot;: {&quot;text&quot;: &quot;1 месяц&quot;, &quot;price&quot;: 550},&#10;        &quot;3_months&quot;: {&quot;text&quot;: &quot;3 месяца&quot;, &quot;price&quot;: 750},&#10;        &quot;forever&quot;: {&quot;text&quot;: &quot;НАВСЕГДА&quot;, &quot;price&quot;: 5000},&#10;    },&#10;    &quot;boost&quot;: {&#10;        &quot;1&quot;: {&quot;text&quot;: &quot;1 поднятие&quot;, &quot;price&quot;: 450},&#10;        &quot;2&quot;: {&quot;text&quot;: &quot;2 поднятия&quot;, &quot;price&quot;: 650},&#10;        &quot;3&quot;: {&quot;text&quot;: &quot;3 поднятия&quot;, &quot;price&quot;: 700},&#10;        &quot;4&quot;: {&quot;text&quot;: &quot;4 поднятия&quot;, &quot;price&quot;: 850},&#10;        &quot;5&quot;: {&quot;text&quot;: &quot;5 поднятий&quot;, &quot;price&quot;: 900},&#10;    },&#10;}&#10;&#10;SUBOPTION_EMOJIS = {&#10;    &quot;pin&quot;: &quot;&quot;,&#10;    &quot;boost&quot;: &quot;⬆️&quot;,&#10;}&#10;&#10;def get_suboption_key(suboption: str, user_type: str, option: str) -&gt; str:&#10;    if suboption == &quot;pin&quot;:&#10;        if option == &quot;1&quot;:&#10;            return &quot;pin_free_chat&quot;&#10;        elif option == &quot;2&quot;:&#10;            return &quot;pin_employer_chat&quot; if user_type == &quot;employer&quot; else &quot;pin_freelancer_chat&quot;&#10;        elif option == &quot;3&quot;:&#10;            return &quot;pin_channel_employer&quot; if user_type == &quot;employer&quot; else &quot;pin_channel_freelancer&quot;&#10;    elif suboption == &quot;boost&quot;:&#10;        return &quot;boost&quot;&#10;    return &quot;&quot;&#10;&#10;# Function to build extra text and keyboard (category buttons)&#10;async def build_extra_text_and_keyboard(state: FSMContext, user_type: str, option: str) -&gt; tuple[str, InlineKeyboardMarkup]:&#10;    data = await state.get_data()&#10;    selected = data.get(&quot;selected_suboptions&quot;, {})&#10;    available = SUBOPTIONS_AVAILABLE.get(user_type, {}).get(option, [])&#10;    base_price = BASE_PRICES[user_type][option]&#10;    desc = DESCRIPTIONS[user_type][option]&#10;    text = desc&#10;    builder = InlineKeyboardBuilder()&#10;    sub_total = 0&#10;    selected_text = &quot;&quot;&#10;&#10;    if available:&#10;        text += &quot;\n\nДополнительные опции:&quot;&#10;        for subopt in available:&#10;            sel_var = selected.get(subopt)&#10;            if sel_var:&#10;                key = get_suboption_key(subopt, user_type, option)&#10;                var_info = PRICES_DICT[key][sel_var]&#10;                price = var_info[&quot;price&quot;]&#10;                sub_total += price&#10;                selected_text += f&quot;\n- {SUBOPTION_EMOJIS[subopt]} {SUBOPTION_NAMES[subopt]} {var_info['text']} ({price}₽)&quot;&#10;            btext = f&quot;{SUBOPTION_EMOJIS[subopt]} {SUBOPTION_NAMES[subopt]}&quot;&#10;            if sel_var:&#10;                btext += f&quot; (выбрано: {PRICES_DICT[get_suboption_key(subopt, user_type, option)][sel_var]['text']})&quot;&#10;            builder.button(text=btext, callback_data=MenuCallback(level=&quot;subextra&quot;, user_type=user_type, option=option, suboption=subopt).pack())&#10;&#10;    total = base_price + sub_total&#10;    if selected_text:&#10;        text += &quot;\n\nВыбранные опции:&quot; + selected_text&#10;    text += f&quot;\n\nИтоговая цена: {total}₽&quot;&#10;&#10;    # Add Buy and Back&#10;    builder.button(text=&quot;Купить&quot;, callback_data=MenuCallback(level=&quot;buy&quot;, user_type=user_type, option=option).pack())&#10;    builder.button(text=&quot;Назад&quot;, callback_data=MenuCallback(level=&quot;sub&quot;, user_type=user_type).pack())&#10;    builder.adjust(2)  # Adjust to 2 per row for better layout&#10;    builder = add_contact_button(builder)&#10;    return text, builder.as_markup()&#10;&#10;# Function to build subextra text and keyboard (variants for a suboption)&#10;async def build_subextra_text_and_keyboard(state: FSMContext, user_type: str, option: str, suboption: str) -&gt; tuple[str, InlineKeyboardMarkup | None]:&#10;    data = await state.get_data()&#10;    selected = data.get(&quot;selected_suboptions&quot;, {})&#10;    key = get_suboption_key(suboption, user_type, option)&#10;    if not key:&#10;        return &quot;Ошибка&quot;, None&#10;    variants = PRICES_DICT[key]&#10;    sel_var = selected.get(suboption)&#10;    text = f&quot;{SUBOPTION_NAMES[suboption]}:&quot;&#10;    if suboption == 'boost':&#10;        text += &quot;\n\nПоднятие — это повторная публикация вашего поста с закрепом на 2 часа. Вы можете выбрать, сколько раз поднять пост.&quot;&#10;&#10;    builder = InlineKeyboardBuilder()&#10;    for var, info in variants.items():&#10;        if sel_var == var:&#10;            btext = f&quot;Удалить опцию {info['text']}&quot;&#10;            act = &quot;remove&quot;&#10;        else:&#10;            btext = f&quot;{info['text']} - {info['price']} рублей&quot;&#10;            act = &quot;add&quot;&#10;        builder.button(text=btext, callback_data=MenuCallback(level=&quot;toggle&quot;, user_type=user_type, option=option, suboption=suboption, variant=var, action=act).pack())&#10;    builder.button(text=&quot;Назад&quot;, callback_data=MenuCallback(level=&quot;extra&quot;, user_type=user_type, option=option).pack())&#10;    builder.adjust(2)&#10;    builder = add_contact_button(builder)&#10;    return text, builder.as_markup()&#10;&#10;# Handler for /start&#10;@menu_router.message(Command(&quot;start&quot;))&#10;async def command_start(message: Message):&#10;    if message.chat.type != 'private':&#10;        return&#10;    text = (&#10;        &quot;Привет! Здесь можно быстро и удобно разместить вакансию или резюме\n\n&quot;&#10;        &quot;Чтобы начать, откройте главное меню командой /menu&quot;&#10;    )&#10;    kb = InlineKeyboardBuilder()&#10;    kb = add_contact_button(kb)&#10;    await message.answer(text, reply_markup=kb.as_markup())&#10;&#10;# Handler for /menu - shows initial menu with employer/freelancer choices&#10;@menu_router.message(Command(&quot;menu&quot;))&#10;async def command_menu(message: Message, state: FSMContext):&#10;    if message.chat.type != 'private':&#10;        return&#10;    await state.clear()&#10;    # Приветственный текст с ссылками&#10;    intro = (&#10;        &quot;Добро пожаловать! Ниже — быстрые ссылки на наши площадки:\n&quot;&#10;        f&quot;• Основной чат: {LINKS['main']}\n&quot;&#10;        f&quot;• Премиум-канал: {LINKS['premium']}\n&quot;&#10;        f&quot;• Бесплатный чат: {LINKS['free']}\n&quot;&#10;        f&quot;• Чат с отзывами: {LINKS['reviews']}\n\n&quot;&#10;        &quot;Выберите категорию.\n&quot;&#10;        &quot;Важно: указывайте верный статус (Фрилансер/Работодатель) — объявления проходят модерацию и при неверном выборе могут быть отклонены.&quot;&#10;    )&#10;    builder = InlineKeyboardBuilder()&#10;    builder.button(text=&quot;А) Для работодателей&quot;, callback_data=MenuCallback(level=&quot;sub&quot;, user_type=&quot;employer&quot;).pack())&#10;    builder.button(text=&quot;Б) Для фрилансеров&quot;, callback_data=MenuCallback(level=&quot;sub&quot;, user_type=&quot;freelancer&quot;).pack())&#10;    builder.adjust(1)  # One button per row&#10;    builder = add_contact_button(builder)&#10;    await message.answer(intro, reply_markup=builder.as_markup())&#10;&#10;# Main callback query handler&#10;@menu_router.callback_query(MenuCallback.filter())&#10;async def process_menu_callback(query: CallbackQuery, callback_data: MenuCallback, state: FSMContext, bot: Bot):&#10;    rus_names = {'freelancer': 'Фрилансера', 'employer': 'Работодателя'}&#10;    level = callback_data.level&#10;    user_type = callback_data.user_type&#10;    option = callback_data.option&#10;    suboption = callback_data.suboption&#10;    variant = callback_data.variant&#10;    action = callback_data.action&#10;&#10;    await query.answer()  # Acknowledge the callback&#10;&#10;    if level == &quot;sub&quot;:&#10;        await state.clear()&#10;        builder = InlineKeyboardBuilder()&#10;        options = [&#10;            (&quot;Бесплатный чат (только закреп)&quot;, &quot;1&quot;),&#10;            (&quot;Платный чат&quot;, &quot;2&quot;),&#10;            (&quot;Канал&quot;, &quot;3&quot;),&#10;            (&quot;Пакет Стандарт&quot;, &quot;4&quot;),&#10;            (&quot;Пакет Стандарт+Закреп&quot;, &quot;5&quot;),&#10;            (&quot;Пакет Премиум&quot;, &quot;6&quot;)&#10;        ]&#10;        for text, opt in options:&#10;            if opt in BASE_PRICES.get(user_type, {}):&#10;                builder.button(text=f&quot;{OPTION_EMOJIS[opt]} {text}&quot;, callback_data=MenuCallback(level=&quot;extra&quot;, user_type=user_type, option=opt).pack())&#10;        builder.button(text=&quot;Назад&quot;, callback_data=MenuCallback(level=&quot;main&quot;).pack())&#10;        builder.adjust(2)&#10;        builder = add_contact_button(builder)&#10;        header = (&#10;            f&quot;Меню для {rus_names[user_type]}:\n\n&quot;&#10;            &quot;— Выберите площадку или пакет размещения ниже.\n&quot;&#10;            &quot;— Важно: указывайте верный статус (Фрилансер/Работодатель) — объявление проходит модерацию и при неверном выборе может быть отклонено.&quot;&#10;        )&#10;        await query.message.edit_text(header, reply_markup=builder.as_markup())&#10;&#10;    elif level == &quot;extra&quot;:&#10;        data = await state.get_data()&#10;        current_option = data.get('option')&#10;        if current_option != option:&#10;            selected = {}&#10;        else:&#10;            selected = data.get('selected_suboptions', {})&#10;        await state.update_data(user_type=user_type, option=option, selected_suboptions=selected)&#10;        text, markup = await build_extra_text_and_keyboard(state, user_type, option)&#10;        await query.message.edit_text(text, reply_markup=markup)&#10;&#10;    elif level == &quot;subextra&quot;:&#10;        text, markup = await build_subextra_text_and_keyboard(state, user_type, option, suboption)&#10;        await query.message.edit_text(text, reply_markup=markup)&#10;&#10;    elif level == &quot;toggle&quot;:&#10;        data = await state.get_data()&#10;        selected = data.get(&quot;selected_suboptions&quot;, {})&#10;        subopt_name = SUBOPTION_NAMES.get(suboption, suboption)&#10;        key = get_suboption_key(suboption, user_type, option)&#10;        var_info = PRICES_DICT[key].get(variant, {})&#10;        var_text = var_info.get(&quot;text&quot;, variant)&#10;        if action == &quot;add&quot;:&#10;            selected[suboption] = variant&#10;            await query.answer(f&quot;К заказу добавлена опция {subopt_name} {var_text}&quot;)&#10;        elif action == &quot;remove&quot;:&#10;            if suboption in selected:&#10;                del selected[suboption]&#10;            await query.answer(f&quot;Опция {subopt_name} удалена из заказа&quot;)&#10;        await state.update_data(selected_suboptions=selected)&#10;        # Return to subextra view after toggle&#10;        text, markup = await build_subextra_text_and_keyboard(state, user_type, option, suboption)&#10;        await query.message.edit_text(text, reply_markup=markup)&#10;&#10;    elif level == &quot;buy&quot;:&#10;        data = await state.get_data()&#10;        selected = data.get(&quot;selected_suboptions&quot;, {})&#10;        base_price = BASE_PRICES[user_type][option]&#10;        sub_total = 0&#10;        for subopt, var in selected.items():&#10;            key = get_suboption_key(subopt, user_type, option)&#10;            sub_total += PRICES_DICT[key][var][&quot;price&quot;]&#10;        total = base_price + sub_total&#10;        await state.update_data(total=total, selected_suboptions=selected)&#10;        await state.set_state(Purchase.waiting_check)&#10;        # Remove buttons from previous message&#10;        await bot.edit_message_reply_markup(chat_id=query.from_user.id, message_id=query.message.message_id, reply_markup=None)&#10;        # Send new message with cancel (без кнопки контакта на этапе оплаты)&#10;        cancel_builder = InlineKeyboardBuilder()&#10;        cancel_builder.button(text=&quot;Отмена&quot;, callback_data=MenuCallback(level=&quot;cancel&quot;).pack())&#10;        final_price_text = (f&quot;Итоговая цена: {total}₽.\nОтправьте фотографию чека оплаты на сумму {total}₽.\n\n&quot;&#10;                            f&quot;Реквизиты для оплаты:\n&quot;&#10;                            f&quot;Сбербанк:\n&quot;&#10;                            f&quot;Даниил Дмитриевич М.\n&quot;&#10;                            f&quot;2202206250331753\n&quot;&#10;                            f&quot;Можно по номеру:\n&quot;&#10;                            f&quot;89164253032&quot;)&#10;        sent_msg = await bot.send_message(query.from_user.id, text=final_price_text, reply_markup=cancel_builder.as_markup())&#10;        await state.update_data(waiting_msg_id=sent_msg.message_id)&#10;&#10;    elif level == &quot;main&quot;:&#10;        await state.clear()&#10;        builder = InlineKeyboardBuilder()&#10;        builder.button(text=&quot;А) Для работодателей&quot;, callback_data=MenuCallback(level=&quot;sub&quot;, user_type=&quot;employer&quot;).pack())&#10;        builder.button(text=&quot;Б) Для фрилансеров&quot;, callback_data=MenuCallback(level=&quot;sub&quot;, user_type=&quot;freelancer&quot;).pack())&#10;        builder.adjust(1)&#10;        builder = add_contact_button(builder)&#10;        await query.message.edit_text(&quot;Выберите категорию:&quot;, reply_markup=builder.as_markup())&#10;&#10;    elif level == &quot;cancel&quot;:&#10;        data = await state.get_data()&#10;        waiting_msg_id = data.get(&quot;waiting_msg_id&quot;)&#10;        if waiting_msg_id:&#10;            await bot.edit_message_text(chat_id=query.from_user.id, message_id=waiting_msg_id, text=&quot;Покупка отменена.&quot;, reply_markup=None)&#10;        await state.clear()&#10;&#10;# Handler for payment check photo&#10;@menu_router.message(Purchase.waiting_check, F.photo)&#10;async def process_check_photo(message: Message, state: FSMContext, bot: Bot):&#10;    photo_id = message.photo[-1].file_id  # Get the highest resolution photo&#10;    await state.update_data(check_photo=photo_id)&#10;    data = await state.get_data()&#10;    waiting_msg_id = data.get('waiting_msg_id')&#10;    if waiting_msg_id:&#10;        # остаёмся без кнопок на этапе оплаты&#10;        await bot.edit_message_text(chat_id=message.chat.id, message_id=waiting_msg_id, text=&quot;Чек получен.&quot;, reply_markup=None)&#10;&#10;    user_type = data.get('user_type')&#10;    hashtag = '#ищу' if user_type == 'employer' else '#помогу'&#10;&#10;    # Следующий шаг (отправка поста) — показываем кнопку контакта и правила по хэштегам&#10;    kb = InlineKeyboardBuilder()&#10;    kb = add_contact_button(kb)&#10;    post_rules_text = (&#10;        &quot;Теперь отправьте пост, который хотите опубликовать.\n\n&quot;&#10;        &quot;&lt;b&gt;Важно:&lt;/b&gt;\n&quot;&#10;        f&quot;• Ваш пост должен содержать обязательный хэштег: &lt;code&gt;{'#ищу' if user_type == 'employer' else '#помогу'}&lt;/code&gt;\n&quot;&#10;        &quot;• Правило сети по хэштегам: для фрилансера обязателен &lt;code&gt;#помогу&lt;/code&gt;, для работодателя — &lt;code&gt;#ищу&lt;/code&gt;.\n&quot;&#10;        &quot;• Кроме обязательного хэштега &lt;code&gt;#ищу&lt;/code&gt; или &lt;code&gt;#помогу&lt;/code&gt; укажите уточняющие хэштеги. &quot;&#10;        &quot;К примеру, &lt;code&gt;#smm&lt;/code&gt; или &lt;code&gt;#менеджер&lt;/code&gt;.\n&quot;&#10;        &quot;• Не забудьте указать свой контакт или форму в объявлении.\n&quot;&#10;        &quot;• Убедитесь, что хэштег присутствует и написан правильно.&quot;&#10;    )&#10;    await bot.send_message(message.chat.id, post_rules_text, reply_markup=kb.as_markup(), parse_mode=ParseMode.HTML)&#10;    await state.set_state(Purchase.waiting_post)&#10;&#10;# Handler for post content&#10;@menu_router.message(Purchase.waiting_post)&#10;async def process_post_content(message: Message, state: FSMContext, bot: Bot, album: List[Message] | None = None):&#10;    data = await state.get_data()&#10;    user_type = data.get('user_type')&#10;    required_hashtag = '#ищу' if user_type == 'employer' else '#помогу'&#10;&#10;    if album:&#10;        # Обработка медиа-группы (альбома)&#10;        content_type = 'photo'&#10;        file_ids = [msg.photo[-1].file_id for msg in album if msg.photo]&#10;        text = next((msg.caption for msg in album if msg.caption), '')  # Caption от первого с текстом&#10;        media_group_id = 0  # используем 0, чтобы не сохранять строковый идентификатор&#10;    else:&#10;        # Одиночное сообщение&#10;        media_group_id = message.media_group_id&#10;        if message.text:&#10;            content_type = 'text'&#10;            text = message.text&#10;            file_ids = []&#10;        elif message.photo:&#10;            content_type = 'photo'&#10;            text = message.caption or ''&#10;            file_ids = [message.photo[-1].file_id]&#10;        else:&#10;            kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;            await message.answer(&quot;Пожалуйста, отправьте текст или фото.&quot;, reply_markup=kb.as_markup())&#10;            return&#10;&#10;    # Проверка хэштега (регистронезависимо)&#10;    if required_hashtag.lower() not in (text or '').lower():&#10;        kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;        await message.reply(&#10;            f&quot;Ошибка: в вашем посте отсутствует обязательный хэштег &lt;code&gt;{required_hashtag}&lt;/code&gt;. &quot;&#10;            f&quot;Пожалуйста, исправьте и отправьте пост заново.&quot;,&#10;            reply_markup=kb.as_markup(),&#10;            parse_mode=ParseMode.HTML&#10;        )&#10;        return&#10;&#10;    await state.update_data(content_type=content_type, text=text, file_ids=file_ids, media_group_id=media_group_id)&#10;&#10;    # Generate unique order ID&#10;    order_id = str(uuid.uuid4())&#10;&#10;    # Store order data&#10;    pending_orders[order_id] = {&#10;        'user_id': message.from_user.id,&#10;        'user_username': message.from_user.username,&#10;        'user_type': data['user_type'],&#10;        'option': data['option'],&#10;        'selected_suboptions': data['selected_suboptions'],&#10;        'total': data['total'],&#10;        'check_photo': data['check_photo'],&#10;        'content_type': content_type,&#10;        'text': text,&#10;        'file_ids': file_ids,&#10;        'media_group_id': media_group_id&#10;    }&#10;&#10;    # Format suboptions string&#10;    suboptions_str = ', '.join([f&quot;{SUBOPTION_NAMES.get(k, k)}: {PRICES_DICT[get_suboption_key(k, data['user_type'], data['option'])][v]['text']}&quot; for k, v in data['selected_suboptions'].items()]) if data['selected_suboptions'] else 'Нет'&#10;&#10;    # If post has photos, send them to admin first&#10;    if file_ids:&#10;        media = [InputMediaPhoto(media=file_id, caption=text if i == 0 else None, parse_mode=ParseMode.HTML) for i, file_id in enumerate(file_ids)]&#10;        await bot.send_media_group(ADMIN_CHAT_ID, media)&#10;        post_str = &quot;Пост: опубликован выше&quot;&#10;    else:&#10;        await bot.send_message(ADMIN_CHAT_ID, text)&#10;        post_str = f&quot;Пост: опубликован выше&quot;&#10;&#10;    # Build admin keyboard&#10;    builder = InlineKeyboardBuilder()&#10;    builder.button(text=&quot;Подтвердить&quot;, callback_data=AdminCallback(action=&quot;confirm&quot;, order_id=order_id).pack())&#10;    builder.button(text=&quot;Отклонить&quot;, callback_data=AdminCallback(action=&quot;reject&quot;, order_id=order_id).pack())&#10;    builder.adjust(2)&#10;&#10;    # Send check photo with caption and buttons to admin&#10;    caption = (&#10;        f&quot;Новый заказ #{order_id[:8]}\n&quot;&#10;        f&quot;От пользователя: @{message.from_user.username} (ID: {message.from_user.id})\n&quot;&#10;        f&quot;Тип: {data['user_type'].capitalize()}\n&quot;&#10;        f&quot;Опция: {DESCRIPTIONS[data['user_type']][data['option']].splitlines()[0]}\n&quot;&#10;        f&quot;Дополнительные опции: {suboptions_str}\n&quot;&#10;        f&quot;Сумма: {data['total']}₽\n&quot;&#10;        f&quot;{post_str}&quot;&#10;    )&#10;    await bot.send_photo(ADMIN_CHAT_ID, photo=data['check_photo'], caption=caption, reply_markup=builder.as_markup(), parse_mode=ParseMode.HTML)&#10;&#10;    # Пользователю — ответ с кнопкой контакта&#10;    kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;    await message.answer(&quot;Пост получен и отправлен на модерацию. Спасибо!&quot;, reply_markup=kb.as_markup())&#10;    await state.clear()&#10;&#10;# Admin callback handler&#10;@menu_router.callback_query(AdminCallback.filter())&#10;async def process_admin_callback(query: CallbackQuery, callback_data: AdminCallback, state: FSMContext, bot: Bot):&#10;    from datetime import datetime, timedelta&#10;    import os&#10;    import pytz&#10;    from app.database import requests as req&#10;&#10;    order_id = callback_data.order_id&#10;    action = callback_data.action&#10;&#10;    if action == 'reject':&#10;        await state.update_data(order_id_to_reject=order_id)&#10;        # Убираем инлайн-клавиатуру у сообщения с заказом&#10;        try:&#10;            await query.message.edit_reply_markup(reply_markup=None)&#10;        except Exception:&#10;            await bot.edit_message_reply_markup(chat_id=query.message.chat.id, message_id=query.message.message_id, reply_markup=None)&#10;        await query.message.answer(&quot;Введите причину отклонения заказа:&quot;)&#10;        await state.set_state(AdminReject.waiting_reason)&#10;        await query.answer()&#10;        return&#10;&#10;    def parse_pin_variant_to_delta(var: str) -&gt; timedelta | None:&#10;        mapping = {&#10;            '1_week': timedelta(weeks=1),&#10;            '2_weeks': timedelta(weeks=2),&#10;            '3_weeks': timedelta(weeks=3),&#10;            '1_month': timedelta(days=30),&#10;            '2_months': timedelta(days=60),&#10;            '3_months': timedelta(days=90),&#10;            '6_months': timedelta(days=180),&#10;            'forever': None,&#10;        }&#10;        return mapping.get(var)&#10;&#10;    def forever_dt(tz) -&gt; datetime:&#10;        return tz.localize(datetime.strptime(&quot;12:00 31-12-2200&quot;, &quot;%H:%M %d-%m-%Y&quot;))&#10;&#10;    def compute_targets(user_type: str, option: str) -&gt; List[int | str] | List[List[int | str]]:&#10;        # Для пакетов возвращаем список чатов, для обычных — один&#10;        free_chat = int(os.getenv('FREE_CHAT_ID', '0'))&#10;        main_chat = int(os.getenv('MAIN_CHAT_ID', '0'))&#10;        channel = int(os.getenv('CHANNEL_ID', '0'))  # теперь это премиум-канал&#10;        if option == '1':&#10;            return [free_chat]&#10;        if option == '2':&#10;            return [main_chat]&#10;        if option == '3':&#10;            return [channel]&#10;        if option in ('4', '5', '6'):&#10;            return [main_chat, channel, free_chat]&#10;        return [channel]&#10;&#10;    def get_boost_count(selected: dict) -&gt; int:&#10;        try:&#10;            var = selected.get('boost')&#10;            return int(var) if var and var.isdigit() else 0&#10;        except Exception:&#10;            return 0&#10;&#10;    await query.answer()&#10;&#10;    if order_id in pending_orders:&#10;        order = pending_orders.pop(order_id)&#10;        user_id = order['user_id']&#10;&#10;        if action == &quot;confirm&quot;:&#10;            # Сохраняем пост(ы) в БД как ScheduledPost по целевым чатам&#10;            tz = pytz.timezone(&quot;Europe/Moscow&quot;)&#10;            now = datetime.now(tz)&#10;            scheduled_time = now + timedelta(seconds=90)&#10;            selected = order.get('selected_suboptions', {})&#10;            user_type = order['user_type']&#10;            option = order['option']&#10;            pin_variant = selected.get('pin')&#10;            pin_delta = parse_pin_variant_to_delta(pin_variant) if pin_variant else None&#10;            boost_count = get_boost_count(selected)&#10;&#10;            # Время удаления: все размещения теперь навсегда&#10;            delete_time_base = forever_dt(tz)&#10;&#10;            targets = compute_targets(user_type, option)&#10;            for chat_id in targets:&#10;                # unpin_time по правилам для основной публикации:&#10;                if option == '4':&#10;                    # Пакет 4: закреп только в бесплатном чате на 1 месяц&#10;                    if chat_id == int(os.getenv('FREE_CHAT_ID', '0')):&#10;                        unpin_time = now + timedelta(days=30)&#10;                    else:&#10;                        unpin_time = None&#10;                elif option == '5':&#10;                    # Пакет 5: закреп 1 месяц во всех входящих чатиках&#10;                    unpin_time = now + timedelta(days=30)&#10;                elif option == '6':&#10;                    # Пакет 6: закреп навсегда&#10;                    unpin_time = forever_dt(tz)&#10;                else:&#10;                    # Обычные: если выбрана опция pin — берём её, forever -&gt; 2200; иначе без закрепа&#10;                    if pin_delta is not None:&#10;                        unpin_time = now + pin_delta&#10;                    elif pin_variant == 'forever':&#10;                        unpin_time = forever_dt(tz)&#10;                    else:&#10;                        unpin_time = None&#10;&#10;                # delete_time по правилам&#10;                delete_time = delete_time_base&#10;&#10;                # Основная публикация&#10;                await req.add_or_update_scheduled_post(&#10;                    content_type=order['content_type'],&#10;                    text=order['text'],&#10;                    photo_file_ids=order['file_ids'],&#10;                    scheduled_time=scheduled_time.replace(tzinfo=None),  # в БД без tz&#10;                    media_group_id=order['media_group_id'] or 0,&#10;                    unpin_time=unpin_time.replace(tzinfo=None) if unpin_time else None,&#10;                    delete_time=delete_time.replace(tzinfo=None) if delete_time else None,&#10;                    chat_id=int(chat_id)&#10;                )&#10;&#10;                # Поднятия: дублируем пост boost_count раз, каждые +2 часа, с закрепом на 2 часа&#10;                for i in range(1, boost_count + 1):&#10;                    st = (now + timedelta(hours=2 * i)).replace(tzinfo=None)&#10;                    unpin_boost = (now + timedelta(hours=2 * i + 2)).replace(tzinfo=None)&#10;                    await req.add_or_update_scheduled_post(&#10;                        content_type=order['content_type'],&#10;                        text=order['text'],&#10;                        photo_file_ids=order['file_ids'],&#10;                        scheduled_time=st,&#10;                        media_group_id=order['media_group_id'] or 0,&#10;                        unpin_time=unpin_boost,&#10;                        delete_time=delete_time.replace(tzinfo=None) if delete_time else None,&#10;                        chat_id=int(chat_id)&#10;                    )&#10;&#10;            # Уведомление пользователю с кнопкой контакта&#10;            kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;            await bot.send_message(user_id, &quot;Ваш заказ подтверждён! Посты запланированы к публикации.&quot;, reply_markup=kb.as_markup())&#10;            status = &quot;Подтверждено&quot;&#10;&#10;        await query.message.edit_caption(caption=query.message.caption + f&quot;\n\nСтатус: {status}&quot;, reply_markup=None)&#10;    else:&#10;        await query.answer(&quot;Заказ не найден или уже обработан.&quot;)&#10;&#10;# Новый обработчик для получения причины отклонения от админа&#10;@menu_router.message(AdminReject.waiting_reason)&#10;async def process_rejection_reason(message: Message, state: FSMContext, bot: Bot):&#10;    reason = message.text&#10;    data = await state.get_data()&#10;    order_id = data.get('order_id_to_reject')&#10;&#10;    if order_id in pending_orders:&#10;        order = pending_orders.pop(order_id)&#10;        user_id = order['user_id']&#10;&#10;        # Отправляем пользователю сообщение с причиной&#10;        kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;        await bot.send_message(&#10;            user_id,&#10;            f&quot;Ваш заказ был отклонён.\n\n&lt;b&gt;Причина:&lt;/b&gt; {reason}&quot;,&#10;            reply_markup=kb.as_markup(),&#10;            parse_mode=ParseMode.HTML&#10;        )&#10;&#10;        # Обновляем сообщение в админском чате&#10;        # (Предполагается, что админ отвечает на сообщение с заказом, но это сложно отследить без reply)&#10;        # Проще просто уведомить админа, что причина отправлена&#10;        await message.answer(f&quot;Причина отклонения для заказа #{order_id[:8]} отправлена пользователю.&quot;)&#10;&#10;    await state.clear()&#10;&#10;&#10;# Fallback for wrong input in states&#10;@menu_router.message(Purchase.waiting_check)&#10;async def invalid_check(message: Message):&#10;    kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;    await message.answer(&quot;Пожалуйста, отправьте фотографию чека.&quot;, reply_markup=kb.as_markup())&#10;&#10;@menu_router.message(Purchase.waiting_post)&#10;async def invalid_post(message: Message):&#10;    kb = InlineKeyboardBuilder(); kb = add_contact_button(kb)&#10;    await message.answer(&quot;Пожалуйста, отправьте текст или фото.&quot;, reply_markup=kb.as_markup())&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>